---
title: 14 储存过程
urlname: vovxtc2fr88k1icl
date: '2024-03-14 12:12:36'
updated: '2024-05-12 18:26:18'
cover: 'https://raw.githubusercontent.com/choodsire666/blog-img/main/14 储存过程/fc225937f3f486654b02bd480385c0e0.png'
description: 笔记来源：黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括1 介绍存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的...
---
**笔记来源：**[**黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括**](https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&vd_source=e8046ccbdc793e09a75eb61fe8e84a30)
## 1 介绍
存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。
![](https://raw.githubusercontent.com/choodsire666/blog-img/main/14 储存过程/fc225937f3f486654b02bd480385c0e0.png)
特点:

- 封装，复用，可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。
- 可以接收参数，也可以返回数据， 再存储过程中，可以传递参数，也可以接收返回值。
- 减少网络交互，效率提升， 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。
## 2 基本语法
**创建**
```plsql
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ]) 
BEGIN
      -- SQL语句 
END ;
```

**调用**
```plsql
CALL 名称 ([ 参数 ]);
```

**查看**
```plsql
-- 查询指定数据库的存储过程及状态信息
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx';

-- 查询某个存储过程的定义
SHOW CREATE PROCEDURE 存储过程名称 ;
```

**删除**
```plsql
DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；
```

> 注意:在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。


演示示例:
```sql
-- 存储过程基本语法 

-- 创建 
create procedure p1() 
begin
    select count(*) from student; 
end; 

-- 调用 call p1(); 

-- 查看 
select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; 
show create procedure p1; 

-- 删除 
drop procedure if exists p1;
```
## 3 变量
在MySQL中变量分为三种类型: 

- 系统变量
- 用户定义变量
- 局部变量。
### 3.1 系统变量
系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。

**查看系统变量**
```sql

-- 查看所有系统变量 
SHOW [ SESSION | GLOBAL ] VARIABLES ; 

-- 可以通过LIKE模糊匹配方 式查找变量 
SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......'; 

-- 查看指定变量的值
SELECT @@[SESSION | GLOBAL] 系统变量名;
```

**设置系统变量**
```plsql
SET [ SESSION | GLOBAL ] 系统变量名 = 值 ; 
SET @@[SESSION | GLOBAL]系统变量名 = 值 ;
```

注意
> 如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。
mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。
A. 全局变量(GLOBAL): 全局变量针对于所有的会话。
B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。


演示示例：
```plsql
-- 查看系统变量 
show session variables ; 
show session variables like 'auto%'; 
show global variables like 'auto%'; 
select @@global.autocommit; 
select @@session.autocommit; 

-- 设置系统变量 
set session autocommit = 1; 
insert into course(id, name) VALUES (6, 'ES'); 
set global autocommit = 0; 
select @@global.autocommit;
```
### 3.2 用户定义变量
用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 `@ 变量名`使用就可以。其作用域为当前连接。

**赋值**
方式一:
```sql
-- 为多个自定义的变量赋值，中间用逗号隔开
SET @var_name = expr [, @var_name = expr] ... ; 
SET @var_name := expr [, @var_name := expr] ... ;
```
赋值时，可以使用 = ，也可以使用 :=

方式二:
```plsql
SELECT @var_name := expr [, @var_name := expr] ... ; 
SELECT 字段名 INTO @var_name FROM 表名;
```

**使用**
```plsql
SELECT @var_name ;
```
> 注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。


演示示例:
```sql
-- 赋值 
set @myname = 'itcast'; 
set @myage := 10; 
set @mygender := '男',@myhobby := 'java'; 

select @mycolor := 'red'; 
select count(*) into @mycount from tb_user; 

-- 使用 
select @myname,@myage,@mygender,@myhobby; 
select @mycolor , @mycount;
select @abc;
```
### 3.3 局部变量
局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。

**声明**
```sql
DECLARE 变量名 变量类型 [DEFAULT ... ] ;
```
变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。

**赋值**
```plsql
SET 变量名 = 值 ; 
SET 变量名 := 值 ; 
SELECT 字段名 INTO 变量名 FROM 表名 ... ;
```

演示示例：
```plsql
-- 声明局部变量 - declare 
-- 赋值 
create procedure p2() 
begin
    declare stu_count int default 0; 
    select count(*) into stu_count from student; 
    select stu_count; 
end; 


call p2();
```

## 4 if
介绍：if 用于做条件判断，具体的语法结构为：
```plsql
IF 条件1 THEN 
..... 
ELSEIF 条件2 THEN       -- 可选 
..... 
ELSE                   -- 可选 
..... 
END IF;
```
在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。

案例：根据定义的分数score变量，判定当前分数对应的分数等级。

- score >= 85分，等级为优秀。
- score >= 60分 且 score < 85分，等级为及格。
- score < 60分，等级为不及格。
```plsql
create procedure p3() 
begin
    declare score int default 58; 
    declare result varchar(10); 

    if score >= 85 then 
        set result := '优秀'; 
    elseif score >= 60 then 
        set result := '及格'; 
    else
        set result := '不及格'; 
    end if; 
    select result; 
end; 

call p3();
```
上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。
那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？答案是肯定的，我们可以通过接下来所讲解的 参数 来解决上述的问题。
## 5 参数
介绍：参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：

| 类型 | 含义 | 备注 |
| --- | --- | --- |
| IN | 该类参数作为输入，也就是需要调用时传入值 | 默认 |
| OUT | 该类参数作为输出，也就是该参数可以作为返回值 |  |
| INOUT | 既可以作为输入参数，也可以作为输出参数 |  |


用法：
```plsql
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ]) 
BEGIN
    -- SQL语句 
END ;
```

案例一：根据传入参数score，判定当前分数对应的分数等级，并返回。

- score >= 85分，等级为优秀。
- score >= 60分 且 score < 85分，等级为及格。
- score < 60分，等级为不及格。
```plsql
create procedure p4(in score int, out result varchar(10)) 
begin
    if score >= 85 then 
        set result := '优秀'; 
    elseif score >= 60 then
        set result := '及格'; 
    else
        set result := '不及格'; 
    end if; 
end; 

-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明 
call p4(18, @result); 

select @result;
```

案例二：将传入的200分制的分数，进行换算，换算成百分制，然后返回。
```plsql
create procedure p5(inout score double) 
begin
    set score := score * 0.5; 
end; 

set @score = 198; 

call p5(@score); 

select @score;
```
## 6 case
介绍：case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：

语法一
```plsql
-- 含义： 当case_value的值为 when_value1时，执行statement_list1，
--当值为 when_value2时， 执行statement_list2， 否则就执行 statement_list 

CASE case_value 

    WHEN when_value1 THEN statement_list1 
    [ WHEN when_value2 THEN statement_list2] ... 
    [ ELSE statement_list ] 

END CASE;
```

语法2：
```plsql
-- 含义： 当条件search_condition1成立时，执行statement_list1，
--当条件search_condition2成 立时，执行statement_list2， 否则就执行 statement_list 
CASE
    WHEN search_condition1 THEN statement_list1
    [WHEN search_condition2 THEN statement_list2] ... 
    [ELSE statement_list] 
END CASE;
```

案例：根据传入的月份，判定月份所属的季节（要求采用case结构）。

- 1-3月份，为第一季度
- 4-6月份，为第二季度
- 7-9月份，为第三季度
- 10-12月份，为第四季度
```plsql
create procedure p6(in month int) 
begin
    declare result varchar(10); 
    case
        when month >= 1 and month <= 3 then 
            set result := '第一季度'; 
        when month >= 4 and month <= 6 then 
            set result := '第二季度'; 
        when month >= 7 and month <= 9 then 
            set result := '第三季度';
        when month >= 10 and month <= 12 then 
            set result := '第四季度'; 
        else
            set result := '非法参数'; 
    end case ; 

    select concat('您输入的月份为: ',month, ', 所属的季度为: ',result); 
end; 

call p6(16);
```
> 注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。


## 7 while
介绍：while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：
```plsql
-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑 

WHILE 条件 DO 
    SQL逻辑... 
END WHILE;
```

案例：计算从1累加到n的值，n为传入的参数值。
```plsql
-- A. 定义局部变量, 记录累加之后的值; 
-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环 
create procedure p7(in n int) 
begin
    declare total int default 0; 
    while n>0 do
        set total := total + n; 
        set n := n - 1; 
    end while; 

    select total; 
end; 

call p7(100);
```
## 8 repeat
介绍：repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：
```plsql
-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环 
REPEAT
    SQL逻辑... 
    UNTIL 条件 
END REPEAT;
```

案例：计算从1累加到n的值，n为传入的参数值。(使用repeat实现)
```plsql
-- A. 定义局部变量, 记录累加之后的值; 
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 
create procedure p8(in n int) 
begin
    declare total int default 0; 

    repeat
        set total := total + n; 
        set n := n - 1; 
    until n <= 0 
    end repeat; 

    select total;
end; 

call p8(10); 
call p8(100);
```
## 9 loop
介绍：LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。
LOOP可以配合一下两个语句使用：

- LEAVE ：配合循环使用，退出循环。
- ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。

```plsql
[begin_label:] LOOP 
    SQL逻辑... 
END LOOP [end_label];
```
```sql
LEAVE label; -- 退出指定标记的循环体 
ITERATE label; -- 直接进入下一次循环
```
类似于java中的continue和break
上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。

案例一：计算从1累加到n的值，n为传入的参数值。
```plsql
-- A. 定义局部变量, 记录累加之后的值; 
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx 
create procedure p9(in n int) 
begin
    declare total int default 0; 

    sum:loop 
        if n<=0 then 
            leave sum;
        end if; 
        set total := total + n; 
        set n := n - 1; 
    end loop sum; 
    select total; 
end; 

call p9(100);
```

案例二：计算从1到n之间的偶数累加的值，n为传入的参数值。
```plsql
-- A. 定义局部变量, 记录累加之后的值; 
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx 
-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. ----- > iterate xx 
create procedure p10(in n int) 
begin
    declare total int default 0; 

    sum:loop 
        if n<=0 then 
            leave sum; 
        end if; 

        if n%2 = 1 then 
            set n := n - 1; 
            iterate sum; 
        end if; 

        set total := total + n; 
        set n := n - 1; 
    end loop sum;

    select total; 
end; 

call p10(100);
```
## 10 游标
介绍：游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。

**声明游标**
```plsql
DECLARE 游标名称 CURSOR FOR 查询语句 ;
```

**打开游标**
```plsql
OPEN 游标名称 ;
```

**获取游标记录**
```plsql
FETCH 游标名称 INTO 变量 [, 变量 ] ;
```

**关闭游标**
```plsql
CLOSE 游标名称 ;
```

案例：根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。
```sql
-- 逻辑: 
-- A. 声明游标, 存储查询结果集 
-- B. 准备: 创建表结构 
-- C. 开启游标 
-- D. 获取游标中的记录 
-- E. 插入数据到新表中
-- F. 关闭游标

create procedure p11(in uage int) 
begin
    declare uname varchar(100); 
    declare upro varchar(100); 
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;

    drop table if exists tb_user_pro; 
    create table if not exists tb_user_pro( 
        id int primary key auto_increment, 
        name varchar(100), 
        profession varchar(100)
    );

    open u_cursor; 
    while true do 
        fetch u_cursor into uname,upro; 
        insert into tb_user_pro values (null, uname, upro);
    end while; 

    close u_cursor; 
end; 


call p11(30);
```

上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。
![](https://raw.githubusercontent.com/choodsire666/blog-img/main/14 储存过程/f98b75f0fc01deb8d2bb7ebc00cb7afd.png)
但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。
![](https://raw.githubusercontent.com/choodsire666/blog-img/main/14 储存过程/a16a20d57d74c0b7d2bb8902d668617b.png)
上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。
要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。
## 11 条件处理程序
介绍：条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：
```plsql
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ; 
handler_action 的取值： 
    CONTINUE: 继续执行当前程序 
    EXIT: 终止执行当前程序 

condition_value 的取值： 
    SQLSTATE sqlstate_value: 状态码，如 02000 

    SQLWARNING: 所有以01开头的SQLSTATE代码的简写 
    NOT FOUND: 所有以02开头的SQLSTATE代码的简写 
    SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写
```

案例：我们继续来完成在上一小节提出的这个需求，并解决其中的问题。根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。

1. 通过SQLSTATE指定具体的状态码
```sql
-- 逻辑: 
-- A. 声明游标, 存储查询结果集 
-- B. 准备: 创建表结构 
-- C. 开启游标 
-- D. 获取游标中的记录 
-- E. 插入数据到新表中
-- F. 关闭游标

create procedure p11(in uage int) 
begin
    declare uname varchar(100); 
    declare upro varchar(100); 
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;

    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出 
    declare exit handler for SQLSTATE '02000' close u_cursor;

    drop table if exists tb_user_pro; 
    create table if not exists tb_user_pro( 
        id int primary key auto_increment, 
        name varchar(100), 
        profession varchar(100)
    );

    open u_cursor; 
    while true do 
        fetch u_cursor into uname,upro; 
        insert into tb_user_pro values (null, uname, upro);
    end while; 

    close u_cursor; 
end; 


call p11(30);
```

2. 通过SQLSTATE的代码简写方式 NOT FOUND
02 开头的状态码，代码简写为 NOT FOUND
```sql
-- 逻辑: 
-- A. 声明游标, 存储查询结果集 
-- B. 准备: 创建表结构 
-- C. 开启游标 
-- D. 获取游标中的记录 
-- E. 插入数据到新表中
-- F. 关闭游标

create procedure p11(in uage int) 
begin
    declare uname varchar(100); 
    declare upro varchar(100); 
    declare u_cursor cursor for select name,profession from tb_user where age <= uage;

    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出
    declare exit handler for not found close u_cursor;

    drop table if exists tb_user_pro; 
    create table if not exists tb_user_pro( 
        id int primary key auto_increment, 
        name varchar(100), 
        profession varchar(100)
    );

    open u_cursor; 
    while true do 
        fetch u_cursor into uname,upro; 
        insert into tb_user_pro values (null, uname, upro);
    end while; 

    close u_cursor; 
end; 


call p11(30);
```
具体的错误状态码，可以参考官方文档：
[https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html](https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html)
[https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html](https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html)

## 12 存储函数
介绍：存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：
```plsql
CREATE FUNCTION 存储函数名称 ([ 参数列表 ]) 
RETURNS type [characteristic ...] 
BEGIN
    -- SQL语句 
    RETURN ...; 
END ;
```

characteristic说明：

- DETERMINISTIC：相同的输入参数总是产生相同的结果
- NO SQL ：不包含 SQL 语句。
- READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。

案例：计算从1累加到n的值，n为传入的参数值。
```plsql
create function fun1(n int) 
returns int deterministic 
begin
    declare total int default 0; 
    while n>0 do 
        set total := total + n; 
        set n := n - 1; 
    end while; 

    return total; 
end; 

select fun1(50);
```
在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报如下错误：
![](https://raw.githubusercontent.com/choodsire666/blog-img/main/14 储存过程/1d4b05cf4e6eafab8d1f93ea5cb74c2c.png)
