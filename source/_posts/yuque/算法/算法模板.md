---
title: 算法模板
urlname: mungbnpyyb5lvyqt
date: '2024-07-01 12:31:54'
updated: '2025-05-05 19:53:39'
description: 快速排序快速排序import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer;  public clas...
cover: 'https://cdn.jsdelivr.net/gh/choodsire666/blog-img/算法模板/cover.jpg'
---
## 快速排序
### [快速排序](https://www.acwing.com/problem/content/787/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }

        quick_sort(q, 0, n - 1);

        for (int i = 0;i < n;++i) {
            System.out.print(q[i] + " ");
        }
    }

    public static void quick_sort(int q[],int l,int r) {
        // 终止条件
        if (l >= r) {
            return;
        }

        // 找到一个基准值, 找中间的可以防止最坏情况(原来有序或基本有序)
        // l + (r - 1 >> 1) 可以防止溢出
        int x = q[l + (r - l >> 1)];
        // 为后面逻辑统一
        int i = l - 1;
        int j = r + 1;
        while (i < j) {
            // 找到第一个比基准值大的值
            while (q[++i] < x);
            // 找到第一个比基准值小的值
            while (q[--j] > x);

            // 不一样就交换
            if (i < j) {
                swap(q, i, j);
            }
        }

        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }

    public static void swap(int q[], int a, int b) {
        int temp = q[a];
        q[a] = q[b];
        q[b] = temp;
    }
}
```

### [第k个数](https://www.acwing.com/problem/content/788/)
```java
import java.io.*;
import java.util.*;

public class Main {
    public static int N = 100010;
    public static int p[] = new int[N];
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int k = Integer.valueOf(st.nextToken());
        
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            p[i] = Integer.valueOf(st.nextToken());
        }
        
        quickSort(0, n - 1);
        
        System.out.printf("%d", p[k - 1]);
    }
    
    public static void quickSort(int l, int r) {
        if (l >= r) {
            return;
        }
        
        int x = p[l + (r - l >> 1)];
        int i = l - 1;
        int j = r + 1;
        while (i < j) {
            while (p[++i] < x);
            while (p[--j] > x);
            
            if (i < j) {
                int temp = p[i];
                p[i] = p[j];
                p[j] = temp;
            }
        }
        
        quickSort(l, j);
        quickSort(j + 1, r);
    }
}
```

## 归并排序
### [归并排序](https://www.acwing.com/problem/content/789/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }

        merge_sort(q, 0, n - 1);

        for (int i = 0;i < n;++i) {
            System.out.print(q[i] + " ");
        }
    }

    public static void merge_sort(int q[], int l, int r) {
        if (l >= r) return;

        int mid = l + (r - l >> 1);

        merge_sort(q, l, mid);
        merge_sort(q, mid + 1, r);

        int i = l;
        int j = mid + 1;
        int k = 0;
        int tmp[] = new int[r - l + 1];
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) tmp[k++] = q[i++];
            else tmp[k++] = q[j++];
        }

        while (i <= mid) tmp[k++] = q[i++];
        while (j <= r) tmp[k++] = q[j++];

        System.arraycopy(tmp, 0, q, l, tmp.length);
    }
}
```

### [逆序对的数量](https://www.acwing.com/problem/content/790/)(归并)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }
        
        System.out.println(merge_sort(q, 0, n - 1));
    }

    public static long merge_sort(int q[], int l, int r) {
        if (l >= r) return 0;
        long res = 0; // 需要注意，高精度加法。

        int mid = l + (r - l >> 1);
        
        res += merge_sort(q, l, mid);
        res += merge_sort(q, mid + 1, r);

        int tmp[] = new int[r - l + 1];
        int i = l;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) tmp[k++] = q[i++];
            else {
                res += mid - i + 1;
                tmp[k++] = q[j++];
            }
        }

        while (i <= mid) tmp[k++] = q[i++];
        while (j <= r) tmp[k++] = q[j++];
        
        System.arraycopy(tmp, 0, q, l, tmp.length);
        
        return res;
    }
}
```

## 二分
### [数的范围](https://www.acwing.com/problem/content/791/)（二分）
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());

        int x[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            x[i] = Integer.valueOf(st.nextToken());
        }

        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            int l = 0;
            int r = n - 1;

            int t = Integer.valueOf(st.nextToken());
            while (l < r) {
                int mid = l + (r - l >> 1);
                if (x[mid] >= t) r = mid;
                else l = mid + 1;
            }

            if (x[l] != t) System.out.println("-1 -1");
            else {
                System.out.print(l);

                l = 0;
                r = n - 1;
                while (l < r) {
                    int mid = l + (r - l + 1 >> 1);
                    if (x[mid] <= t) l = mid;
                    else r = mid - 1;
                }

                System.out.println(" " + l);
            }
        }
    }
}
```

### [数的三次方根](https://www.acwing.com/problem/content/792/)
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        double x = in.nextDouble();

        double l = -10000, r = 10000;
        while (r - l > 1e-8) {
            double mid = l + (r - l) / 2;
            if (check(mid, x)) r = mid;
            else l = mid;
        }

        System.out.printf("%.6f", l);
    }

    public static boolean check(double x, double t) {
        if (x * x * x >= t) return true;
        return false;
    }
}
```

## 高精度
### [高精度加法](https://www.acwing.com/problem/content/793/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String a = in.nextLine();
        String b = in.nextLine();

        int A[] = new int[a.length()];
        int B[] = new int[b.length()];

        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';
        for (int i = b.length() - 1;i >= 0;--i) B[b.length() - 1 - i] = b.charAt(i) - '0';

        List<Integer> C = add(A, B);
        
        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static List<Integer> add(int A[], int B[]) {
        List<Integer> C = new ArrayList<>();
        
        for (int i = 0, t = 0;i < A.length || i < B.length || t != 0;++i) {
            if (i < A.length) t += A[i];
            if (i < B.length) t += B[i];

            C.add(t % 10);
            t /= 10;
        }
        
        return C;
    }
}
```

### [高精度减法](https://www.acwing.com/problem/content/794/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        String b = in.nextLine();

        int A[] = new int[a.length()];
        int B[] = new int[b.length()];

        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';
        for (int i = b.length() - 1;i >= 0;--i) B[b.length() - 1 - i] = b.charAt(i) - '0';

        List<Integer> C = null;
        if (compare(a, b)) {
            C = sub(A, B);            
        } else {
            C = sub(B, A);
            System.out.print("-");
        }    

        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static boolean compare(String a, String b) {
        if (a.length() > b.length()) return true;
        else if (a.length() < b.length()) return false;

        for (int i = 0;i < a.length();++i) {
            if (a.charAt(i) > b.charAt(i)) return true;
            else if (a.charAt(i) < b.charAt(i)) return false;
        }

        return true;
    }

    public static List<Integer> sub(int A[], int B[]) {
        List<Integer> C = new ArrayList<>();

        for (int i = 0, t = 0;i < A.length || i < B.length || t != 0;++i) {
            t = A[i] - t;
            if (i < B.length) t -= B[i];
            C.add((t + 10) % 10);            
            if (t < 0) t = 1;
            else t = 0;
        }

        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
        
        return C;
    }
}
```

### [高精度乘法](https://www.acwing.com/problem/content/795/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        int b = in.nextInt();

        int A[] = new int[a.length()];
        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';

        List<Integer> C = mul(A, b);

        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static List<Integer> mul(int A[], int b) {
        List<Integer> C = new ArrayList<>();

        for (int i = 0, t = 0;i < A.length || t != 0;++i) {
            if (i < A.length) t += A[i] * b;
            C.add(t % 10);
            t /= 10;
        }

        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
        
        return C;
    }
}
```

### [高精度除法](https://www.acwing.com/problem/content/796/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        int b = in.nextInt();

        int A[] = new int[a.length()];
        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 -i] = a.charAt(i) - '0';

        R R = div(A, b);
        List<Integer> C = R.C;
        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
        System.out.println();
        System.out.println(R.r);
    }

    public static R div(int A[], int b) {
        List<Integer> C = new ArrayList<>();

        int r = 0;
        for (int i = A.length - 1;i >= 0;--i) {
            r = r * 10 + A[i];
            C.add(r / b);
            r %= b;
        }

        Collections.reverse(C);
        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);

        R R = new R();
        R.C = C;
        R. r = r;
        
        return R;
    }

    private static class R {
       public List<Integer> C;
       public int r;
    }
}
```

## 前缀和和差分
### [前缀和](https://www.acwing.com/problem/content/797/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }
            q[i] = Integer.valueOf(st.nextToken());
        }

        int ans[] = new int[n + 1];
        ans[0] = 0;
        for (int i = 1;i < n + 1;++i) {
            ans[i] = ans[i - 1] + q[i - 1];
        }

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            int a = Integer.valueOf(st.nextToken());
            int b = Integer.valueOf(st.nextToken());

            System.out.println(ans[b] - ans[a - 1]);
        }
    }
}
```

### [子矩阵的和](https://www.acwing.com/problem/content/798/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());
        
        int x[][] = new int[n][m];
        int s[][] = new int[n + 1][m + 1];

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }
            for (int j = 0;j < m;++j) {
                x[i][j] = Integer.valueOf(st.nextToken());
            }
        }

        for (int i = 1;i < n + 1;++i) {
            for (int j = 1;j < m + 1;++j) {
                s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + x[i-1][j-1];
            }
        }

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            int x1 = Integer.valueOf(st.nextToken());
            int y1 = Integer.valueOf(st.nextToken());
            int x2 = Integer.valueOf(st.nextToken());
            int y2 = Integer.valueOf(st.nextToken());

            System.out.println(s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]);
        }
     }
}
```

### [差分](https://www.acwing.com/problem/content/799/)(（差分）b[i] = a[i] - a[i-1],   (前缀和)a[i] = a[i-1] + b[i])
```java
import java.util.*;

public class Main {
    
    public static int N = 100010;
    public static int q[] = new int[N];
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        for (int i = 1;i <= n;++i) insert(i, i, in.nextInt());
        
        while (m-- != 0) {
            int l = in.nextInt();
            int r = in.nextInt();
            int c = in.nextInt();
            insert(l, r, c);
        }
        
        for (int i = 1;i <= n;++i) {
            q[i] += q[i - 1];
            System.out.printf("%d ", q[i]);
            
        }
    }
    
    public static void insert(int l, int r, int c) {
        q[l] += c;
        q[r + 1] -= c;
    }
}
```

### [差分矩阵](https://www.acwing.com/problem/content/800/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());
        
        int a[][] = new int[n + 10][m + 10];
        st = new StringTokenizer(in.readLine());
        for (int i = 1;i < n + 1;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            for (int j = 1;j < m + 1;++j) {
                insert(a, i, j, i, j, Integer.valueOf(st.nextToken()));
            }
        }
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int x1 = Integer.valueOf(st.nextToken());
            int y1 = Integer.valueOf(st.nextToken());
            int x2 = Integer.valueOf(st.nextToken());
            int y2 = Integer.valueOf(st.nextToken());
            int c = Integer.valueOf(st.nextToken());
            
            insert(a, x1, y1, x2, y2, c);
        }
        
        for (int i = 1;i < n + 1;++i) {
            for (int j = 1;j < m + 1;++j) {
                a[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1];
                System.out.print(a[i][j] + " ");
            }
            
            System.out.println();
        }
    }
    
    public static void insert(int a[][], int x1, int y1, int x2, int y2, int c) {
        a[x1][y1] += c;
        a[x2 + 1][y1] -= c;   
        a[x1][y2 + 1] -= c;
        a[x2 + 1][y2 + 1] += c;   
    }
}
```

## 双指针算法
### [最长连续不重复子序列](https://www.acwing.com/problem/content/801/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.Map;
import java.util.HashMap;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int a[] = new int[n];
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            a[i] = Integer.valueOf(st.nextToken());
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        for (int i = 0,j = 0;i < n;++i) {
            if (map.containsKey(a[i])) {
                map.put(a[i], map.get(a[i]) + 1);   
            } else {
                map.put(a[i], 1);
            }
            while (map.get(a[i]) > 1) {
                map.put(a[j], map.get(a[j]) - 1);
                ++j;
            }
            
            res = res > (i - j + 1) ? res : (i - j  + 1);
        }
        
        System.out.println(res);
    }
}
```

### [数组元素的目标和](https://www.acwing.com/problem/content/802/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = in.nextInt();
        int m = in.nextInt();
        int x = in.nextInt();

        int a[] = new int[n];
        int b[] = new int[m];
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        for (int i = 0;i < m;++i) b[i] = in.nextInt();

        for (int i = 0,j = m - 1;i < n;++i) {
            while (j >= 0 && a[i] + b[j] > x) j--;
            if (j >= 0 && a[i] + b[j] == x) System.out.println(i + " " + j);
        }
    }
}
```

### [判断子序列](https://www.acwing.com/problem/content/description/2818/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        int a[] = new int[n];
        int b[] = new int[m];
        
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        for (int i = 0;i < m;++i) b[i] = in.nextInt();
        
        int check = 0;
        for (int i = 0, j = 0;i < n && j < m;) {
            if (a[i] == b[j]) {
                check++;
                ++i;
                ++j;
            } else {
                ++j;
            }
        }
        
        if (check == n) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
```

## 位运算
### [二进制中1的个数](https://www.acwing.com/problem/content/803/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        
        while (n-- != 0) {
            int a = in.nextInt();
            int res = 0;
            while (a != 0) {
                a -= lowbit(a);
                res++;
            }
            
            System.out.print(res + " ");
        }
    }
    
    public static int lowbit(int a) {
        return a & (~a + 1);
    }
}
```

## 离散化
### [区间和](https://www.acwing.com/problem/content/804/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        
        List<Pair> add = new ArrayList<>();
        List<Integer> alls = new ArrayList<>();
        List<Pair> query = new ArrayList<>();
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            Pair pair = new Pair();
            int x = Integer.valueOf(st.nextToken());
            pair.first = x;
            pair.second = Integer.valueOf(st.nextToken());
            
            add.add(pair);
            
            alls.add(x);
        }
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int l = Integer.valueOf(st.nextToken());
            int r = Integer.valueOf(st.nextToken());
            
            Pair pair = new Pair();
            pair.first = l;
            pair.second = r;
            
            query.add(pair);
            
            alls.add(l);
            alls.add(r);
        }
        
        // alls去重
        alls = unique(alls);
        
        
        int a[] = new int[alls.size() + 1];
        // 前缀和
        for (int i = 0;i < add.size();++i) {
            a[find(alls, add.get(i).first)] += add.get(i).second;
        }
        
        for (int i = 1;i <= alls.size();++i) {
            a[i] += a[i-1];
        }
        
        for (int i = 0;i < query.size();++i) {
            int l = query.get(i).first;
            int r = query.get(i).second;
            l = find(alls, l);
            r = find(alls, r);
            System.out.println(a[r] - a[l-1]);
        }
    }
    
    public static List<Integer> unique(List<Integer> list) {
        Collections.sort(list);
        
        List<Integer> res = new ArrayList<>();
        for (int i = 0;i < list.size();++i) {
            if (i == 0 || list.get(i-1) != list.get(i)) {
                res.add(list.get(i));
            }
        }
        
        return res;
    }
    
    public static int find(List<Integer> alls, int x) {
        int l = 0;
        int r = alls.size() - 1;
        while (l < r) {
            int mid = l + (r - l >> 1);
            if (alls.get(mid) >= x) r = mid;
            else l = mid + 1;
        }
        
        return r + 1;
    }
    
    private static class Pair {
        public int first;
        public int second;
    }
}
```

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        int add[][] = new int[n][2];
        int alls[] = new int[n + m * 2];
        int querys[][] = new int[m][2];
        
        int ai = 0;
        
        for (int i = 0;i < n;++i) {
            int x = in.nextInt();
            int c = in.nextInt();
            add[i][0] = x;
            add[i][1] = c;
            alls[ai++] = x;
        }
        
        for (int i = 0;i < m;++i) {
            int l = in.nextInt();
            int r = in.nextInt();
            querys[i][0] = l;
            querys[i][1] = r;
            alls[ai++] = l;
            alls[ai++] = r;
        }
        
        alls = Arrays.stream(alls).distinct().sorted().toArray();
        
        // insert, 用到前缀和，得+1
        int a[] = new int[alls.length + 1];
        for (int i = 0;i < n;++i) {
            int x = Arrays.binarySearch(alls, add[i][0]) + 1;
            int c = add[i][1];
            a[x] += c;
        }
        
        // 前缀和
        for (int i = 1;i <= alls.length;++i) {
            a[i] += a[i-1];
        }
        
        for (int i = 0;i < m;++i) {
            int l = Arrays.binarySearch(alls, querys[i][0]) + 1;
            int r = Arrays.binarySearch(alls, querys[i][1]) + 1;
            System.out.println(a[r] - a[l-1]);
        }
    }
}
```

## 区间合并
### [区间合并](https://www.acwing.com/problem/content/805/)(排序后贪心)
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] arsg) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        List<Pair> list = new ArrayList<>();
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int l = Integer.valueOf(st.nextToken());
            int r = Integer.valueOf(st.nextToken());
            
            Pair pair = new Pair();
            pair.first = l;
            pair.second = r;
            list.add(pair);
        }
        
        // 排序
        list.sort(Comparator.comparing(l -> l.first));
        
        int res = 1;
        
        int l = list.get(0).first;
        int r = list.get(0).second;
        
        for (int i = 1;i < list.size();++i) {
            if (r >= list.get(i).first) {
                r = r > list.get(i).second ? r : list.get(i).second;
            } else {
                if (list.get(i).second != r) {
                    l = list.get(i).first;
                    r = list.get(i).second;
                    res++;
                }
            }
        }
        
        System.out.println(res);
    }
    
    private static class Pair {
        public int first;
        public int second;
    }
}
```

## 单链表
[单链表（静态链表实现）](https://www.acwing.com/problem/content/828/)

```java
import java.io.*;
import java.util.*;

public class Main {
    
    public static int e[] = new int[100010];
    public static int ne[] = new int[100010];
    public static int head = -1;
    public static int idx = 0;
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int m = Integer.valueOf(st.nextToken());
        
        init();
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            String ops = st.nextToken();
            switch (ops) {
                case "H": {
                    add(Integer.valueOf(st.nextToken()));
                    break;   
                }
                case "D": {
                    int k = Integer.valueOf(st.nextToken());
                    if (k == 0) head = ne[head];
                    else remove(k - 1);
                    break;
                }
                case "I": {
                    insert(Integer.valueOf(st.nextToken()) - 1, Integer.valueOf(st.nextToken()));
                    break;   
                }
                default:
                    break;
            }
        }
        
        for (int i = head;i != -1;i = ne[i]) {
            System.out.print(e[i] + " ");
        }
    }
    
    public static void init() {
        head = -1;
        idx = 0;
    }
    
    public static void add(int x) {
        e[idx] = x;
        ne[idx] = head;
        head = idx++;
    }
    
    public static void insert(int k, int x) {
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx++;
    }
    
    public static void remove(int k) {
        ne[k] = ne[ne[k]];
    }
}
```

## 双链表
### [双链表](https://www.acwing.com/problem/content/829/)
```java
import java.util.*;

public class Main {
    
    static int e[] = new int[100010];
    static int l[] = new int[100010];
    static int r[] = new int[100010];
    static int idx;
    
    static {
        r[0] = 1;
        l[1] = 0;
        idx = 2;
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int m = in.nextInt();
        while (m-- != 0) {
            String op = in.next();
            switch (op) {
                case "L": {
                    l(in.nextInt());
                    break;
                }
                case "R": {
                    r(in.nextInt());
                    break;
                }
                case "D": {
                    del(in.nextInt());
                    break;
                }
                case "IL": {
                    int k = in.nextInt();
                    add(l[++k], in.nextInt());
                    break;
                }
                case "IR": {
                    int k = in.nextInt();
                    add(++k, in.nextInt());
                    break;
                }
            }
        }
        
        int i = 0;
        while (r[i] != 1) {
            i = r[i];
            System.out.print(e[i] + " ");
        }
    }
    
    public static void add(int k, int x) {
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = k;
        l[r[k]] = idx;
        r[k] = idx++;
    }
    
    public static void l(int x) {
        add(0, x);
    }
    
    public static void r(int x) {
        add(l[1], x);
    }
    
    public static void del(int k) {
        k++;
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
}
```

## 栈
### [模拟栈](https://www.acwing.com/problem/content/830/)
```java
import java.util.*;

public class Main {
    
    static int stk[] = new int[100010];
    static int tt;
    
    static {
        tt = 0;
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int m = in.nextInt();
        
        while (m-- != 0) {
            String op = in.next();
            switch (op) {
                case "push": {
                    push(in.nextInt());
                    break;
                }
                case "pop": {
                    pop();
                    break;
                }
                case "query": {
                    System.out.println(query());
                    break;
                }
                case "empty": {
                    System.out.println(empty());
                    break;
                }
            }
        }
    }
    
    public static void push(int x) {
        stk[tt++] = x;
    }
    
    public static int pop() {
        return stk[--tt];
    }
    
    public static String empty() {
        return tt > 0 ? "NO": "YES";
    }
    
    public static int query() {
        return stk[tt - 1];
    }
}
```

### [表达式求值](https://www.acwing.com/problem/content/3305/)
```java
import java.util.*;

public class Main {
    static char signal[] = new char[100010];
    static int value[] = new int[100010];
    static int si = 0;
    static int vi = 0;
    static Map<Character, Integer> p = new HashMap<>();
    
    static {
        p.put('(', 0);
        p.put('+', 1);
        p.put('-', 1);
        p.put('*', 2);
        p.put('/', 2);
        p.put(')', 3);
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        String s = in.next();
        
        for (int i = 0;i < s.length();++i) {
            char a = s.charAt(i);
            if ('0' <= a && a <= '9') {
                int j = i;
                int num = 0;
                while (j < s.length() && '0' <= s.charAt(j) && s.charAt(j) <= '9') {
                    num = num * 10 + (s.charAt(j) - '0');
                    j++;
                }
                i = j - 1;
                // 入栈
                value[vi++] = num;
            } else if ('(' == a) {
                // 入栈
                signal[si++] = a;
            } else if (')' == a) {
              while (signal[si - 1] != '(') {
                  eval();
              }  
              --si;
            } else if (si == 0) {
                signal[si++] = a;
            }
            else {
                while (si > 0 && p.get(signal[si - 1]) >= p.get(a)) {
                  // 先计算，再入栈
                  eval();
                }
                signal[si++] = a;
            }
        }
        
        while (vi > 1) {
            eval();
        }
        
        System.out.println(value[0]);
    }
    
    public static void eval() {
        int a = value[--vi];
        int b = value[--vi];
        char op = signal[--si];
        
        // 计算
        int res = 0;
        switch (op) {
            case '+': {
                res = b + a;       
                break;
            }
            case '-': {
                res = b - a;
                break;
            }
            case '*': {
                res = b * a;
                break;
            }
            case '/': {
                res = b / a;
                break;
            }
        }
        
        // 入栈
        value[vi++] = res;
    }
}
```

## 队列
### [模拟队列](https://www.acwing.com/problem/content/831/)
```java
import java.util.*;

public class Main {
    
    static int queue[] = new int[100010];
    static int first = -1;
    static int last = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        while (n-- != 0) {
            String op = in.next();
            switch (op) {
                case "push": {
                    push(in.nextInt());
                    break;
                }
                case "pop": {
                    pop();
                    break;
                }
                case "empty": {
                    System.out.println(empty() ? "YES" : "NO");
                    break;
                }
                case "query": {
                    System.out.println(query());
                    break;
                }
            }
        }
    }
    
    public static void push(int x) {
        queue[last++] = x;
    }
    
    public static int pop() {
        return queue[++first];
    }
    
    public static boolean empty() {
        if (first + 1 == last) {
            return true;
        }
        
        return false;
    }
    
    public static int query() {
        return queue[first + 1];
    }
}
```

## 单调栈
### [单调栈](https://www.acwing.com/problem/content/832/)
暴力解法（TLE）

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        int a[] = new int[n];
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        
        for (int i = 0;i < n;++i) {
            int res = -1;
            for (int j = i - 1;j >= 0;--j) {
                if (a[j] < a[i]) {
                    res = a[j];
                    break;
                }
            }
            
            System.out.print(res + " ");
        }
    }
}
```

单调栈解法

```java
import java.util.*;

public class Main {
    
    static int stack[] = new int[100010];
    static int p = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        int a[] = new int[n];
        for (int i = 0;i < n;++i) {
            int x = in.nextInt();
            while (p > 0 && stack[p - 1] >= x) {
                --p;
            }
            
            if (p > 0) {
                System.out.print(stack[p-1] + " ");
            } else {
                System.out.print("-1 ");
            }
            
            stack[p++] = x;
        }
    }
}
```

## 单调队列
### [滑动窗口](https://www.acwing.com/problem/content/156/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
    
        int n = Integer.valueOf(st.nextToken());
        int k = Integer.valueOf(st.nextToken());
        
        int a[] = new int[1000010];
        int q[] = new int[1000010];
        
        int hh = 0, tt = -1;
        
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            a[i] = Integer.valueOf(st.nextToken());
        }
        
        for (int i = 0;i < n;++i) {
            if (hh <= tt && q[hh] < i - k + 1) ++hh;
            while (hh <= tt && a[q[tt]] >= a[i]) --tt;
            q[++tt] = i;
            
            if (i >= k - 1) log.write(a[q[hh]] + " ");
        }
        
        log.newLine();
        
        hh = 0;
        tt = -1;
        
        for (int i = 0;i < n;++i) {
            if (hh <= tt && q[hh] < i - k + 1) ++hh;
            while (hh <= tt && a[q[tt]] <= a[i]) --tt;
            q[++tt] = i;
            
            if (i >= k - 1) log.write(a[q[hh]] + " ");
        }
        
        log.flush();
        
        log.close();
        in.close();
    }
}
```

## KMP
### [kmp字符串](https://www.acwing.com/problem/content/833/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        char p[] = new char[100010];
        char s[] = new char[1000010];
        int ne[] = new int[100010];
        
        int n = Integer.valueOf(st.nextToken());
        st = new StringTokenizer(in.readLine());
        String s1 = st.nextToken();
        for (int i = 0;i < s1.length();++i) {
            p[i+1] = s1.charAt(i);
        }

        st = new StringTokenizer(in.readLine());    
        int m = Integer.valueOf(st.nextToken());
        
        st = new StringTokenizer(in.readLine());   
        String s2 = st.nextToken();
        for (int i = 0;i < s2.length();++i) {
            s[i+1] = s2.charAt(i);
        }
        
        
        for (int i = 2, j = 0;i <= n;++i) {
            while (j > 0 && p[i] != p[j+1]) j = ne[j];
            if (p[i] == p[j+1]) ++j;
            ne[i] = j;
        }
        
        int i = 1, j = 0;
        for (i = 1;i <= m;++i) {
            while (j > 0 && s[i] != p[j+1]) j = ne[j];
            if (s[i] == p[j+1]) ++j;
            if (j == n) {
                // 匹配成功
                log.write((i - n) + " ");
                j = ne[j];
            }
        }
        
        log.flush();
        log.close();
        in.close();
    }
}
```

## Tire字符串统计
### [Trie字符串统计](https://www.acwing.com/problem/content/837/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        Map<String, Integer> map = new HashMap<>();
        
        st = new StringTokenizer(in.readLine());   
        while (n-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());   
            }
            String op = st.nextToken();
            String value = st.nextToken();
            
            if ("I".equals(op)) {
                if (map.containsKey(value)) {
                    map.put(value, map.get(value) + 1);
                } else {
                    map.put(value, 1);
                }
            } else if ("Q".equals(op)) {
                if (map.containsKey(value)) {
                    out.write("" + map.get(value));
                    out.newLine();
                } else {
                    out.write("0");
                    out.newLine();
                }
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
}
```



```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static int N = 100010;
    private static int son[][] = new int[N][26];
    private static int cnt[] = new int[N * 26];
    private static int idx;
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        st = new StringTokenizer(in.readLine());   
        while (n-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());   
            }
            String op = st.nextToken();
            String value = st.nextToken();
            
            if ("I".equals(op)) {
                insert(value.toCharArray());
            } else {
                out.write("" + query(value.toCharArray()));
                out.newLine();
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
    
    private static void insert(char[] str) {
        int p = 0;
        for (int i = 0;i < str.length;++i) {
            int u = str[i] - 'a';
            if (son[p][u] == 0) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }
    
    private static int query(char[] str) {
        int p = 0;
        for (int i = 0;i < str.length;++i) {
            int u = str[i] - 'a';
            if (son[p][u] == 0) return 0;
            p = son[p][u];
        }
        
        return cnt[p];
    }
}
```

### [最大异或对](https://www.acwing.com/problem/content/145/)
```java
import java.util.*;

public class Main {
    
    private static int N = 100010; // 数字数量
    private static int M = 31 * N; // 行数
    private static int son[][] = new int[M][2]; // 每位0或1
    private static int idx;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int a[] = new int[n];
        
        for (int i = 0;i < n;++i) {
            a[i] = in.nextInt();
            insert(a[i]);
        }
        
        int res = 0;
        for (int i = 0;i < n;++i) {
            res = Math.max(res, query(a[i]));
        }
        
        System.out.println(res);
    }
    
    private static void insert(int x) {
        int p = 0;
        for (int i = 30;i >= 0;--i) {
            int s = x >> i & 1;
            if (son[p][s] == 0) son[p][s] = ++idx;
            p = son[p][s];
        }
    }
    
    private static int query(int x) {
        int p = 0;
        int res = 0;
        for (int i = 30;i >= 0;--i) {
            int s = (x >> i & 1) == 1 ? 0 : 1;
            if (son[p][s] != 0) {
                res += 1 << i;
                p = son[p][s];
            } else {
                s = s == 1 ? 0 : 1;
                p = son[p][s];
            }
        }
        
        return res;
    }
}
```

## 并查集
### [合并集合](https://www.acwing.com/problem/content/description/838/)
```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static int N = 100010;
    private static int p[] = new int[N];
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        
        for (int i = 0;i < n;++i) {
            p[i] = i;
        }
        
        st = new StringTokenizer(in.readLine());
        while (m-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            String op = st.nextToken();
            int x = Integer.valueOf(st.nextToken());
            int y = Integer.valueOf(st.nextToken());
            
            if ("M".equals(op)) {
                p[find(x)] = find(y);
            } else {
                out.write(find(x) == find(y) ? "Yes" : "No");
                out.newLine();
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
    
    private static int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        
        return p[x];
    }
}
```



### [连通块中点的数量](https://www.acwing.com/problem/content/839/)
```java
import java.util.*;

public class Main {
    
    private static int N = 100010;
    private static int p[] = new int[N];
    private static int size[] = new int[N];
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        for (int i = 0;i < n;++i) {
            p[i] = i;
            size[i] = 1;
        } 
        
        while (m-- != 0) {
            String op = in.next();
            
            if ("C".equals(op)) {
                int x = in.nextInt();
                int y = in.nextInt();
                if(find(x) == find(y)) continue;
                size[find(y)] = size[find(x)] + size[find(y)];
                p[find(x)] = find(y);
            } else if ("Q1".equals(op)) {
                int x = in.nextInt();
                int y = in.nextInt();
                System.out.println(find(x) == find(y) ? "Yes" : "No");
            } else {
                int x = in.nextInt();
                System.out.println(size[find(x)]);
            }
        }
    }
    
    private static int find(int x) {
        if (x != p[x]) {
            p[x] = find(p[x]);
        }
        
        return p[x];
    }
}
```



### [食物链](https://www.acwing.com/problem/content/242/)
```java
import java.util.*;

public class Main {
    
    private static int N = 50010;
    private static int p[] = new int[N];
    private static int d[] = new int[N];
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int k = in.nextInt();
        
        for (int i = 1;i <= n;++i) p[i] = i;
        
        int res = 0;
        
        while (k-- != 0) {
            int t = in.nextInt();
            int x = in.nextInt();
            int y = in.nextInt();
            
            if (x > n || y > n) {
                res++;
            } else {
                int px = find(x);
                int py = find(y);
                
                if (t == 1) {
                    // 同类
                    if (px == py && (d[x] - d[y]) % 3 != 0) {
                        // 假的
                        res++;
                    } else if (px != py) {
                        // 真的
                        p[px] = py;
                        d[px] = d[y] - d[x];
                    }
                } else {
                    // X吃Y
                    if (px == py && (d[x] - d[y] - 1) % 3 != 0) {
                        res++;
                    } else if (px != py) {
                        p[px] = py;
                        d[px] = d[y] - d[x] + 1;
                    }
                }
            }
        }
        
        System.out.println(res);
    }

    /**
    * 压缩路径， 并查集可以多保存额外信息，此处保存了路径信息
    */
    private static int find(int x) {
        if (x != p[x]) {
            int t = find(p[x]);
            d[x] += d[p[x]];
            p[x] = t;
        }
        
        return p[x];
    }
}
```



## 堆
### [堆排序](https://www.acwing.com/problem/)
```java
import java.util.*;

public class Main {
    
    private static int n, m;
    private static int N = 100010;
    private static int h[] = new int[N];
    private static int size = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        n = in.nextInt();
        m = in.nextInt();
        
        for (int i = 1;i <= n;++i) h[i] = in.nextInt();
        size = n;
        
        // 调整树, 从最后的非叶子结点开始
        // 只要孩子节点小于该节点，就进行交换
        for (int i = n / 2;i != 0;--i) adjust(i);
        
        while (m-- != 0) {
            // 得到堆顶元素
            System.out.print(h[1] + " ");
            // 将堆顶元素和最后一个节点交互
            swap(1, size);
            // 逻辑删除
            size--;
            adjust(1);
        }
    }
    
    private static void adjust(int u) {
        int t = u;
        // 如果左子树存在，且孩子节点小于该节点
        if (u * 2 <= size && h[u * 2] < h[t]) {
            t = u * 2;
        }
        // 如果右子树存在，且孩子节点小于该节点
        if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) {
            t = u * 2 + 1;
        }
        if (u != t) {
            // 将本节点和孩子节点进行交换
            swap(u, t);
            // 递归判断子树
            adjust(t);
        }
    }

    private static void swap(int a, int b) {
        int temp = h[a];
        h[a] = h[b];
        h[b] = temp;
    }
}
```



## 深度优先搜索
### [排列数字](https://www.acwing.com/problem/content/844/)
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

#define N 8
// 定义是否访问过该结点, 从1开始
int visit[N];
// 定义路径, 从1开始
int path[N];
int n;

// 深度优先算法, 递归输出排列方案
void dfs(int h) {
    // 递归出口, 到第n层时说明到达叶子结点
    if (h > n) {
        for (int i = 1;i <= n;++i) {
            printf("%d ", path[i]);
        }
        printf("\n");
        return;
    }
    // 循环选择没有访问过的结点, 进行递归
    for (int i = 1;i <= n;++i) {
        if (!visit[i]) {
            path[h] = i;
            // 修改成访问过
            visit[i] = 1;
            dfs(h + 1);
            // 还原现场
            visit[i] = 0;
        }
    }
}

int main()
{
    scanf("%d", &n);
    dfs(1);
    return 0;
}
```

### [n-皇后问题](https://www.acwing.com/problem/content/845/)
```cpp
#include "iostream"

using namespace std;

#define N 10

// 定义二维矩阵, 存放棋盘, '.'代表空的, 'Q'代表放置皇后, 从[1][1]开始
char graph[N][N];
// 代表第i列有没有放置皇后
int column[N];
// 代表主对角线上有没有放置皇后
int diag[2*N + 1];
// 代表副对角线上有没有放置皇后
int antiDiag[2*N + 1];
int n;

// 深度优先搜索, 一行一行放置皇后
void dfs(int row) {
    // 递归出口, 当row大于n时,表示都放置完毕
    if (row > n) {
        // 输出棋盘放置皇后结果
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                printf("%c", graph[i][j]);
            }
            printf("\n");
        }
        printf("\n");
        return;
    }

    // 循环列, 判断皇后放置位置, 并递归放置
    for (int col = 1; col <= n; ++col) {
        if (!column[col] && !antiDiag[row + col] && !diag[n - row + col]) {
            // 放置
            graph[row][col] = 'Q';
            column[col] = antiDiag[row + col] = diag[n - row + col] = 1;
            // 递归放置
            dfs(row + 1);
            // 还原
            column[col] = antiDiag[row + col] = diag[n - row + col] = 0;
            graph[row][col] = '.';
        }
    }
}

int main() {
    scanf("%d", &n);
    // 棋盘初始化
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            graph[i][j] = '.';
        }
    }
    dfs(1);
    return 0;
}
```

## 广度优先搜索
### [走迷宫](https://www.acwing.com/problem/content/846/)
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

#define N 110

int graph[N][N];
// 目标坐标
int n, m;

// 存放坐标
typedef pair<int, int> PII;
PII queue[N * N];

// 存放距离
int dis[N][N];

void bfs() {
    // 初始化距离
    memset(dis, -1, sizeof dis);
    // 初始化队列
    int front = 0, rear = 0;
    // 起点入队
    queue[rear++] = {1, 1};
    dis[1][1] = 0;

    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    while (front != rear) {
        PII position = queue[front++];

        // 枚举4个方向
        for (int i = 0; i < 4; ++i) {
            int x = position.first + dx[i];
            int y = position.second + dy[i];

            // 范围限制, 合法性判断
            if (x >= 1 && x <= n && y >= 1 && y <= m && graph[x][y] == 0 && dis[x][y] == -1) {
                dis[x][y] = dis[position.first][position.second] + 1;
                // 坐标入队
                queue[rear++] = {x, y};
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            scanf("%d", &graph[i][j]);
        }
    }
    
    bfs();
    printf("%d", dis[n][m]);
    return 0;
}
```

### [八数码](https://www.acwing.com/problem/content/847/)
```cpp
#include "iostream"
#include "algorithm"
#include "queue"

using namespace std;


int bfs(const string &start) {
    string end = "12345678x";
    // 初始化队列和map
    queue<string> q;
    unordered_map<string, int> dist;

    // 起始状态入栈
    q.push(start);
    // 保存状态转移次数
    dist[start] = 0;

    // 定义四个方向
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};

    while (!q.empty()) {
        string cur = q.front();
        q.pop();

        int curDist = dist[cur];

        if (cur == end) return curDist;

        // 找出索引
        int k = (int) cur.find('x');
        // 计算坐标
        int x = k / 3;
        int y = k % 3;

        // 枚举4个方向
        for (int i = 0; i < 4; ++i) {
            int a = x + dx[i];
            int b = y + dy[i];

            if (a >= 0 && a < 3 && b >= 0 && b < 3) {
                // 交换字符
                swap(cur[a * 3 + b], cur[k]);
                if (!dist.count(cur)) {
                    dist[cur] = curDist + 1;
                    q.push(cur);
                }
                // 还原现场
                swap(cur[a * 3 + b], cur[k]);
            }
        }
    }

    return -1;
}

int main() {
    string start;
    for (int i = 0; i < 9; ++i) {
        char c;
        cin >> c;
        start += c;
    }

    cout << bfs(start) << endl;
    return 0;
}
```

## 最短路径
### [Dijkstra单源最短路径算法 (带权图(网), 正权)](https://www.acwing.com/problem/content/description/851/)
```cpp
#include "iostream"
#include "cstring"

using namespace std;

#define N 510

// 定义邻接矩阵
int graph[N][N];
// 定义到各个结点的距离
int dist[N];
// 定义是否访问过该结点
int visit[N];

int n, m;

int dijkstra() {
    // 初始化所有点距离为无穷大
    memset(dist, 0x3f, sizeof dist);
    // 设定到第一个点距离为0, 即起点
    dist[1] = 0;

    // 每次源点到一个点的最短距离, 有n个点需找n次
    for (int i = 1; i <= n; ++i) {
        // 找目前离源点最近的点(未找到最短距离的点中)
        // 该处可优化 (最小堆)
        int t = -1;
        for (int j = 1; j <= n; ++j) {
            if (!visit[j] && (t == -1 || dist[j] < dist[t])) {
                t = j;
            }
        }

        // 找到最短距离
        visit[t] = 1;

        // 迭代到其他点的距离
        for (int j = 1; j <= n; ++j) {
            dist[j] = min(dist[j], dist[t] + graph[t][j]);
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    scanf("%d%d", &n, &m);
    // 初始化所有边为无穷大
    memset(graph, 0x3f, sizeof graph);

    while (m--) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        // 去除重边和自环
        graph[a][b] = min(graph[a][b], c);
    }

    printf("%d", dijkstra());
    return 0;
}
```

### [Dijkstra堆优化版](https://www.acwing.com/problem/content/description/852/)
```cpp
#include "iostream"
#include "cstring"
#include "queue"

#define N 150010

using namespace std;

// h头指针, w存放边的权值, e存放边终点索引, ne存放下一条边索引, idx全局索引
int h[N], w[N], e[N], ne[N], idx;

int n, m;

// 定义距离
int dist[N];
// 定义是否找到最短距离
int visit[N];

// {距离, 点}, 按距离排序 (升序)
typedef pair<int, int> PII;

// 加边, 构造邻接表
void add(int a, int b, int c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dijkstra() {
    // 初始化距离为无穷大
    memset(dist, 0x3f, sizeof dist);
    // 定义源点距离为0
    dist[1] = 0;

    // 定义最小堆, 用于获取当前已知距离的最小的结点(未找出最短距离中的点)
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});

    while (!heap.empty()) {
        PII minPoint = heap.top();
        heap.pop();

        int distance = minPoint.first;
        int vert = minPoint.second;

        // 如果已经找过了, 就跳过
        if (visit[vert]) continue;
        visit[vert] = 1;

        // 迭代到其他点的距离, 并放入堆中
        for (int i = h[vert]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    scanf("%d%d", &n, &m);

    // 初始化头结点指针为-1
    memset(h, -1, sizeof h);

    while (m--) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d", dijkstra());
    return 0;
}
```

