---
title: 算法模板
urlname: mungbnpyyb5lvyqt
date: '2024-07-01 12:31:54'
updated: '2024-08-22 10:08:19'
description: 快速排序快速排序import java.io.IOException; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer;  public clas...
cover: 'http://raw.githubusercontent.com/gh/choodsire666/blog-img/算法模板/cover.jpg'
---
## 快速排序
### [快速排序](https://www.acwing.com/problem/content/787/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }

        quick_sort(q, 0, n - 1);

        for (int i = 0;i < n;++i) {
            System.out.print(q[i] + " ");
        }
    }

    public static void quick_sort(int q[],int l,int r) {
        if (l >= r) {
            return;
        }

        int x = q[l + (r - l >> 1)];
        int i = l - 1;
        int j = r + 1;
        while (i < j) {
            while (q[++i] < x);
            while (q[--j] > x);

            if (i < j) {
                swap(q, i, j);
            }
        }

        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }

    public static void swap(int q[], int a, int b) {
        int temp = q[a];
        q[a] = q[b];
        q[b] = temp;
    }
}
```
## 归并排序
### [归并排序](https://www.acwing.com/problem/content/789/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }

        merge_sort(q, 0, n - 1);

        for (int i = 0;i < n;++i) {
            System.out.print(q[i] + " ");
        }
    }

    public static void merge_sort(int q[], int l, int r) {
        if (l >= r) return;

        int mid = l + (r - l >> 1);

        merge_sort(q, l, mid);
        merge_sort(q, mid + 1, r);

        int i = l;
        int j = mid + 1;
        int k = 0;
        int tmp[] = new int[r - l + 1];
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) tmp[k++] = q[i++];
            else tmp[k++] = q[j++];
        }

        while (i <= mid) tmp[k++] = q[i++];
        while (j <= r) tmp[k++] = q[j++];

        System.arraycopy(tmp, 0, q, l, tmp.length);
    }
}
```
### [逆序对的数量](https://www.acwing.com/problem/content/790/)(归并)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            q[i] = Integer.valueOf(st.nextToken());
        }
        
        System.out.println(merge_sort(q, 0, n - 1));
    }

    public static long merge_sort(int q[], int l, int r) {
        if (l >= r) return 0;
        long res = 0; // 需要注意，高精度加法。

        int mid = l + (r - l >> 1);
        
        res += merge_sort(q, l, mid);
        res += merge_sort(q, mid + 1, r);

        int tmp[] = new int[r - l + 1];
        int i = l;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) tmp[k++] = q[i++];
            else {
                res += mid - i + 1;
                tmp[k++] = q[j++];
            }
        }

        while (i <= mid) tmp[k++] = q[i++];
        while (j <= r) tmp[k++] = q[j++];
        
        System.arraycopy(tmp, 0, q, l, tmp.length);
        
        return res;
    }
}
```
## 二分
### [数的范围](https://www.acwing.com/problem/content/791/)（二分）
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        int n = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());

        int x[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            x[i] = Integer.valueOf(st.nextToken());
        }

        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            int l = 0;
            int r = n - 1;

            int t = Integer.valueOf(st.nextToken());
            while (l < r) {
                int mid = l + (r - l >> 1);
                if (x[mid] >= t) r = mid;
                else l = mid + 1;
            }

            if (x[l] != t) System.out.println("-1 -1");
            else {
                System.out.print(l);

                l = 0;
                r = n - 1;
                while (l < r) {
                    int mid = l + (r - l + 1 >> 1);
                    if (x[mid] <= t) l = mid;
                    else r = mid - 1;
                }

                System.out.println(" " + l);
            }
        }
    }
}
```
### [数的三次方根](https://www.acwing.com/problem/content/792/)
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        double x = in.nextDouble();

        double l = -10000, r = 10000;
        while (r - l > 1e-8) {
            double mid = l + (r - l) / 2;
            if (check(mid, x)) r = mid;
            else l = mid;
        }

        System.out.printf("%.6f", l);
    }

    public static boolean check(double x, double t) {
        if (x * x * x >= t) return true;
        return false;
    }
}
```
## 高精度
### [高精度加法](https://www.acwing.com/problem/content/793/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String a = in.nextLine();
        String b = in.nextLine();

        int A[] = new int[a.length()];
        int B[] = new int[b.length()];

        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';
        for (int i = b.length() - 1;i >= 0;--i) B[b.length() - 1 - i] = b.charAt(i) - '0';

        List<Integer> C = add(A, B);
        
        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static List<Integer> add(int A[], int B[]) {
        List<Integer> C = new ArrayList<>();
        
        for (int i = 0, t = 0;i < A.length || i < B.length || t != 0;++i) {
            if (i < A.length) t += A[i];
            if (i < B.length) t += B[i];

            C.add(t % 10);
            t /= 10;
        }
        
        return C;
    }
}
```
### [高精度减法](https://www.acwing.com/problem/content/794/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        String b = in.nextLine();

        int A[] = new int[a.length()];
        int B[] = new int[b.length()];

        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';
        for (int i = b.length() - 1;i >= 0;--i) B[b.length() - 1 - i] = b.charAt(i) - '0';

        List<Integer> C = null;
        if (compare(a, b)) {
            C = sub(A, B);            
        } else {
            C = sub(B, A);
            System.out.print("-");
        }    

        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static boolean compare(String a, String b) {
        if (a.length() > b.length()) return true;
        else if (a.length() < b.length()) return false;

        for (int i = 0;i < a.length();++i) {
            if (a.charAt(i) > b.charAt(i)) return true;
            else if (a.charAt(i) < b.charAt(i)) return false;
        }

        return true;
    }

    public static List<Integer> sub(int A[], int B[]) {
        List<Integer> C = new ArrayList<>();

        for (int i = 0, t = 0;i < A.length || i < B.length || t != 0;++i) {
            t = A[i] - t;
            if (i < B.length) t -= B[i];
            C.add((t + 10) % 10);            
            if (t < 0) t = 1;
            else t = 0;
        }

        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
        
        return C;
    }
}
```
### [高精度乘法](https://www.acwing.com/problem/content/795/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        int b = in.nextInt();

        int A[] = new int[a.length()];
        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 - i] = a.charAt(i) - '0';

        List<Integer> C = mul(A, b);

        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
    }

    public static List<Integer> mul(int A[], int b) {
        List<Integer> C = new ArrayList<>();

        for (int i = 0, t = 0;i < A.length || t != 0;++i) {
            if (i < A.length) t += A[i] * b;
            C.add(t % 10);
            t /= 10;
        }

        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
        
        return C;
    }
}
```
### [高精度除法](https://www.acwing.com/problem/content/796/)
```java
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String a = in.nextLine();
        int b = in.nextInt();

        int A[] = new int[a.length()];
        for (int i = a.length() - 1;i >= 0;--i) A[a.length() - 1 -i] = a.charAt(i) - '0';

        R R = div(A, b);
        List<Integer> C = R.C;
        for (int i = C.size() - 1;i >= 0;--i) System.out.print(C.get(i));
        System.out.println();
        System.out.println(R.r);
    }

    public static R div(int A[], int b) {
        List<Integer> C = new ArrayList<>();

        int r = 0;
        for (int i = A.length - 1;i >= 0;--i) {
            r = r * 10 + A[i];
            C.add(r / b);
            r %= b;
        }

        Collections.reverse(C);
        while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);

        R R = new R();
        R.C = C;
        R. r = r;
        
        return R;
    }

    private static class R {
       public List<Integer> C;
       public int r;
    }
}
```
## 前缀和和差分
### [前缀和](https://www.acwing.com/problem/content/797/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());

        int q[] = new int[n];
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }
            q[i] = Integer.valueOf(st.nextToken());
        }

        int ans[] = new int[n + 1];
        ans[0] = 0;
        for (int i = 1;i < n + 1;++i) {
            ans[i] = ans[i - 1] + q[i - 1];
        }

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            int a = Integer.valueOf(st.nextToken());
            int b = Integer.valueOf(st.nextToken());

            System.out.println(ans[b] - ans[a - 1]);
        }
    }
}
```
### [子矩阵的和](https://www.acwing.com/problem/content/798/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());

        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());
        
        int x[][] = new int[n][m];
        int s[][] = new int[n + 1][m + 1];

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }
            for (int j = 0;j < m;++j) {
                x[i][j] = Integer.valueOf(st.nextToken());
            }
        }

        for (int i = 1;i < n + 1;++i) {
            for (int j = 1;j < m + 1;++j) {
                s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + x[i-1][j-1];
            }
        }

        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            int x1 = Integer.valueOf(st.nextToken());
            int y1 = Integer.valueOf(st.nextToken());
            int x2 = Integer.valueOf(st.nextToken());
            int y2 = Integer.valueOf(st.nextToken());

            System.out.println(s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]);
        }
     }
}
```
### [差分](https://www.acwing.com/problem/content/799/)(（差分）b[i] = a[i] - a[i-1],   (前缀和)a[i] = a[i-1] + b[i])
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        
        st = new StringTokenizer(in.readLine());
        // int a[] = new int[n + 1];
        int b[] = new int[n + 1];
        for (int i = 1;i < n + 1;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            insert(b, i, i, Integer.valueOf(st.nextToken()));
        }
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int l = Integer.valueOf(st.nextToken());
            int r = Integer.valueOf(st.nextToken());
            int c = Integer.valueOf(st.nextToken());
            
            insert(b, l, r, c);
        }
        
        for (int i = 1;i < n + 1;++i) {
            b[i] += b[i-1];
            // a[i] = a[i-1] + b[i];
        }
        
        for (int i = 1;i < n + 1;++i) {
            System.out.print(b[i] + " ");
            // System.out.print(a[i] + " ");
        }
    }
    
    public static void insert(int b[], int i, int j, int value) {
        b[i] += value;
        if (j < b.length - 1) {
            b[j + 1] -= value;   
        }
    }
}
```
### [差分矩阵](https://www.acwing.com/problem/content/800/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        int q = Integer.valueOf(st.nextToken());
        
        int a[][] = new int[n + 10][m + 10];
        st = new StringTokenizer(in.readLine());
        for (int i = 1;i < n + 1;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            for (int j = 1;j < m + 1;++j) {
                insert(a, i, j, i, j, Integer.valueOf(st.nextToken()));
            }
        }
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < q;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int x1 = Integer.valueOf(st.nextToken());
            int y1 = Integer.valueOf(st.nextToken());
            int x2 = Integer.valueOf(st.nextToken());
            int y2 = Integer.valueOf(st.nextToken());
            int c = Integer.valueOf(st.nextToken());
            
            insert(a, x1, y1, x2, y2, c);
        }
        
        for (int i = 1;i < n + 1;++i) {
            for (int j = 1;j < m + 1;++j) {
                a[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1];
                System.out.print(a[i][j] + " ");
            }
            
            System.out.println();
        }
    }
    
    public static void insert(int a[][], int x1, int y1, int x2, int y2, int c) {
        a[x1][y1] += c;
        a[x2 + 1][y1] -= c;   
        a[x1][y2 + 1] -= c;
        a[x2 + 1][y2 + 1] += c;   
    }
}
```
## 双指针算法
### [最长连续不重复子序列](https://www.acwing.com/problem/content/801/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.Map;
import java.util.HashMap;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int a[] = new int[n];
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            a[i] = Integer.valueOf(st.nextToken());
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        for (int i = 0,j = 0;i < n;++i) {
            if (map.containsKey(a[i])) {
                map.put(a[i], map.get(a[i]) + 1);   
            } else {
                map.put(a[i], 1);
            }
            while (map.get(a[i]) > 1) {
                map.put(a[j], map.get(a[j]) - 1);
                ++j;
            }
            
            res = res > (i - j + 1) ? res : (i - j  + 1);
        }
        
        System.out.println(res);
    }
}
```
### [数组元素的目标和](https://www.acwing.com/problem/content/802/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = in.nextInt();
        int m = in.nextInt();
        int x = in.nextInt();

        int a[] = new int[n];
        int b[] = new int[m];
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        for (int i = 0;i < m;++i) b[i] = in.nextInt();

        for (int i = 0,j = m - 1;i < n;++i) {
            while (j >= 0 && a[i] + b[j] > x) j--;
            if (j >= 0 && a[i] + b[j] == x) System.out.println(i + " " + j);
        }
    }
}
```
### [判断子序列](https://www.acwing.com/problem/content/description/2818/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        int a[] = new int[n];
        int b[] = new int[m];
        
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        for (int i = 0;i < m;++i) b[i] = in.nextInt();
        
        int check = 0;
        for (int i = 0, j = 0;i < n && j < m;) {
            if (a[i] == b[j]) {
                check++;
                ++i;
                ++j;
            } else {
                ++j;
            }
        }
        
        if (check == n) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
```
## 位运算
### [二进制中1的个数](https://www.acwing.com/problem/content/803/)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        
        while (n-- != 0) {
            int a = in.nextInt();
            int res = 0;
            while (a != 0) {
                a -= lowbit(a);
                res++;
            }
            
            System.out.print(res + " ");
        }
    }
    
    public static int lowbit(int a) {
        return a & (~a + 1);
    }
}
```
## 离散化
### [区间和](https://www.acwing.com/problem/content/804/)
```java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        
        List<Pair> add = new ArrayList<>();
        List<Integer> alls = new ArrayList<>();
        List<Pair> query = new ArrayList<>();
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            Pair pair = new Pair();
            int x = Integer.valueOf(st.nextToken());
            pair.first = x;
            pair.second = Integer.valueOf(st.nextToken());
            
            add.add(pair);
            
            alls.add(x);
        }
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int l = Integer.valueOf(st.nextToken());
            int r = Integer.valueOf(st.nextToken());
            
            Pair pair = new Pair();
            pair.first = l;
            pair.second = r;
            
            query.add(pair);
            
            alls.add(l);
            alls.add(r);
        }
        
        // alls去重
        alls = unique(alls);
        
        
        int a[] = new int[alls.size() + 1];
        // 前缀和
        for (int i = 0;i < add.size();++i) {
            a[find(alls, add.get(i).first)] += add.get(i).second;
        }
        
        for (int i = 1;i <= alls.size();++i) {
            a[i] += a[i-1];
        }
        
        for (int i = 0;i < query.size();++i) {
            int l = query.get(i).first;
            int r = query.get(i).second;
            l = find(alls, l);
            r = find(alls, r);
            System.out.println(a[r] - a[l-1]);
        }
    }
    
    public static List<Integer> unique(List<Integer> list) {
        Collections.sort(list);
        
        List<Integer> res = new ArrayList<>();
        for (int i = 0;i < list.size();++i) {
            if (i == 0 || list.get(i-1) != list.get(i)) {
                res.add(list.get(i));
            }
        }
        
        return res;
    }
    
    public static int find(List<Integer> alls, int x) {
        int l = 0;
        int r = alls.size() - 1;
        while (l < r) {
            int mid = l + (r - l >> 1);
            if (alls.get(mid) >= x) r = mid;
            else l = mid + 1;
        }
        
        return r + 1;
    }
    
    private static class Pair {
        public int first;
        public int second;
    }
}
```
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        int add[][] = new int[n][2];
        int alls[] = new int[n + m * 2];
        int querys[][] = new int[m][2];
        
        int ai = 0;
        
        for (int i = 0;i < n;++i) {
            int x = in.nextInt();
            int c = in.nextInt();
            add[i][0] = x;
            add[i][1] = c;
            alls[ai++] = x;
        }
        
        for (int i = 0;i < m;++i) {
            int l = in.nextInt();
            int r = in.nextInt();
            querys[i][0] = l;
            querys[i][1] = r;
            alls[ai++] = l;
            alls[ai++] = r;
        }
        
        alls = Arrays.stream(alls).distinct().sorted().toArray();
        
        // insert, 用到前缀和，得+1
        int a[] = new int[alls.length + 1];
        for (int i = 0;i < n;++i) {
            int x = Arrays.binarySearch(alls, add[i][0]) + 1;
            int c = add[i][1];
            a[x] += c;
        }
        
        // 前缀和
        for (int i = 1;i <= alls.length;++i) {
            a[i] += a[i-1];
        }
        
        for (int i = 0;i < m;++i) {
            int l = Arrays.binarySearch(alls, querys[i][0]) + 1;
            int r = Arrays.binarySearch(alls, querys[i][1]) + 1;
            System.out.println(a[r] - a[l-1]);
        }
    }
}
```
## 区间合并
### [区间合并](https://www.acwing.com/problem/content/805/)(排序后贪心)
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] arsg) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        List<Pair> list = new ArrayList<>();
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            int l = Integer.valueOf(st.nextToken());
            int r = Integer.valueOf(st.nextToken());
            
            Pair pair = new Pair();
            pair.first = l;
            pair.second = r;
            list.add(pair);
        }
        
        // 排序
        list.sort(Comparator.comparing(l -> l.first));
        
        int res = 1;
        
        int l = list.get(0).first;
        int r = list.get(0).second;
        
        for (int i = 1;i < list.size();++i) {
            if (r >= list.get(i).first) {
                r = r > list.get(i).second ? r : list.get(i).second;
            } else {
                if (list.get(i).second != r) {
                    l = list.get(i).first;
                    r = list.get(i).second;
                    res++;
                }
            }
        }
        
        System.out.println(res);
    }
    
    private static class Pair {
        public int first;
        public int second;
    }
}
```
## 单链表
[单链表（静态链表实现）](https://www.acwing.com/problem/content/828/)
```java
import java.io.*;
import java.util.*;

public class Main {
    
    public static int e[] = new int[100010];
    public static int ne[] = new int[100010];
    public static int head = -1;
    public static int idx = 0;
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int m = Integer.valueOf(st.nextToken());
        
        init();
        
        st = new StringTokenizer(in.readLine());
        for (int i = 0;i < m;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            
            String ops = st.nextToken();
            switch (ops) {
                case "H": {
                    add(Integer.valueOf(st.nextToken()));
                    break;   
                }
                case "D": {
                    int k = Integer.valueOf(st.nextToken());
                    if (k == 0) head = ne[head];
                    else remove(k - 1);
                    break;
                }
                case "I": {
                    insert(Integer.valueOf(st.nextToken()) - 1, Integer.valueOf(st.nextToken()));
                    break;   
                }
                default:
                    break;
            }
        }
        
        for (int i = head;i != -1;i = ne[i]) {
            System.out.print(e[i] + " ");
        }
    }
    
    public static void init() {
        head = -1;
        idx = 0;
    }
    
    public static void add(int x) {
        e[idx] = x;
        ne[idx] = head;
        head = idx++;
    }
    
    public static void insert(int k, int x) {
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx++;
    }
    
    public static void remove(int k) {
        ne[k] = ne[ne[k]];
    }
}
```
## 双链表
### [双链表](https://www.acwing.com/problem/content/829/)
```java
import java.util.*;

public class Main {
    
    static int e[] = new int[100010];
    static int l[] = new int[100010];
    static int r[] = new int[100010];
    static int idx;
    
    static {
        r[0] = 1;
        l[1] = 0;
        idx = 2;
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int m = in.nextInt();
        while (m-- != 0) {
            String op = in.next();
            switch (op) {
                case "L": {
                    l(in.nextInt());
                    break;
                }
                case "R": {
                    r(in.nextInt());
                    break;
                }
                case "D": {
                    del(in.nextInt());
                    break;
                }
                case "IL": {
                    int k = in.nextInt();
                    add(l[++k], in.nextInt());
                    break;
                }
                case "IR": {
                    int k = in.nextInt();
                    add(++k, in.nextInt());
                    break;
                }
            }
        }
        
        int i = 0;
        while (r[i] != 1) {
            i = r[i];
            System.out.print(e[i] + " ");
        }
    }
    
    public static void add(int k, int x) {
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = k;
        l[r[k]] = idx;
        r[k] = idx++;
    }
    
    public static void l(int x) {
        add(0, x);
    }
    
    public static void r(int x) {
        add(l[1], x);
    }
    
    public static void del(int k) {
        k++;
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
}
```
## 栈
### [模拟栈](https://www.acwing.com/problem/content/830/)
```java
import java.util.*;

public class Main {
    
    static int stk[] = new int[100010];
    static int tt;
    
    static {
        tt = 0;
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int m = in.nextInt();
        
        while (m-- != 0) {
            String op = in.next();
            switch (op) {
                case "push": {
                    push(in.nextInt());
                    break;
                }
                case "pop": {
                    pop();
                    break;
                }
                case "query": {
                    System.out.println(query());
                    break;
                }
                case "empty": {
                    System.out.println(empty());
                    break;
                }
            }
        }
    }
    
    public static void push(int x) {
        stk[tt++] = x;
    }
    
    public static int pop() {
        return stk[--tt];
    }
    
    public static String empty() {
        return tt > 0 ? "NO": "YES";
    }
    
    public static int query() {
        return stk[tt - 1];
    }
}
```
### [表达式求值](https://www.acwing.com/problem/content/3305/)
```java
import java.util.*;

public class Main {
    static char signal[] = new char[100010];
    static int value[] = new int[100010];
    static int si = 0;
    static int vi = 0;
    static Map<Character, Integer> p = new HashMap<>();
    
    static {
        p.put('(', 0);
        p.put('+', 1);
        p.put('-', 1);
        p.put('*', 2);
        p.put('/', 2);
        p.put(')', 3);
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        String s = in.next();
        
        for (int i = 0;i < s.length();++i) {
            char a = s.charAt(i);
            if ('0' <= a && a <= '9') {
                int j = i;
                int num = 0;
                while (j < s.length() && '0' <= s.charAt(j) && s.charAt(j) <= '9') {
                    num = num * 10 + (s.charAt(j) - '0');
                    j++;
                }
                i = j - 1;
                // 入栈
                value[vi++] = num;
            } else if ('(' == a) {
                // 入栈
                signal[si++] = a;
            } else if (')' == a) {
              while (signal[si - 1] != '(') {
                  eval();
              }  
              --si;
            } else if (si == 0) {
                signal[si++] = a;
            }
            else {
                while (si > 0 && p.get(signal[si - 1]) >= p.get(a)) {
                  // 先计算，再入栈
                  eval();
                }
                signal[si++] = a;
            }
        }
        
        while (vi > 1) {
            eval();
        }
        
        System.out.println(value[0]);
    }
    
    public static void eval() {
        int a = value[--vi];
        int b = value[--vi];
        char op = signal[--si];
        
        // 计算
        int res = 0;
        switch (op) {
            case '+': {
                res = b + a;       
                break;
            }
            case '-': {
                res = b - a;
                break;
            }
            case '*': {
                res = b * a;
                break;
            }
            case '/': {
                res = b / a;
                break;
            }
        }
        
        // 入栈
        value[vi++] = res;
    }
}
```
## 队列
### [模拟队列](https://www.acwing.com/problem/content/831/)
```java
import java.util.*;

public class Main {
    
    static int queue[] = new int[100010];
    static int first = -1;
    static int last = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        while (n-- != 0) {
            String op = in.next();
            switch (op) {
                case "push": {
                    push(in.nextInt());
                    break;
                }
                case "pop": {
                    pop();
                    break;
                }
                case "empty": {
                    System.out.println(empty() ? "YES" : "NO");
                    break;
                }
                case "query": {
                    System.out.println(query());
                    break;
                }
            }
        }
    }
    
    public static void push(int x) {
        queue[last++] = x;
    }
    
    public static int pop() {
        return queue[++first];
    }
    
    public static boolean empty() {
        if (first + 1 == last) {
            return true;
        }
        
        return false;
    }
    
    public static int query() {
        return queue[first + 1];
    }
}
```
## 单调栈
### [单调栈](https://www.acwing.com/problem/content/832/)
暴力解法（TLE）
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        int a[] = new int[n];
        for (int i = 0;i < n;++i) a[i] = in.nextInt();
        
        for (int i = 0;i < n;++i) {
            int res = -1;
            for (int j = i - 1;j >= 0;--j) {
                if (a[j] < a[i]) {
                    res = a[j];
                    break;
                }
            }
            
            System.out.print(res + " ");
        }
    }
}
```
单调栈解法
```java
import java.util.*;

public class Main {
    
    static int stack[] = new int[100010];
    static int p = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        
        int a[] = new int[n];
        for (int i = 0;i < n;++i) {
            int x = in.nextInt();
            while (p > 0 && stack[p - 1] >= x) {
                --p;
            }
            
            if (p > 0) {
                System.out.print(stack[p-1] + " ");
            } else {
                System.out.print("-1 ");
            }
            
            stack[p++] = x;
        }
    }
}
```
## 单调队列
### [滑动窗口](https://www.acwing.com/problem/content/156/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
    
        int n = Integer.valueOf(st.nextToken());
        int k = Integer.valueOf(st.nextToken());
        
        int a[] = new int[1000010];
        int q[] = new int[1000010];
        
        int hh = 0, tt = -1;
        
        st = new StringTokenizer(in.readLine(), " ");
        for (int i = 0;i < n;++i) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine(), " ");
            }

            a[i] = Integer.valueOf(st.nextToken());
        }
        
        for (int i = 0;i < n;++i) {
            if (hh <= tt && q[hh] < i - k + 1) ++hh;
            while (hh <= tt && a[q[tt]] >= a[i]) --tt;
            q[++tt] = i;
            
            if (i >= k - 1) log.write(a[q[hh]] + " ");
        }
        
        log.newLine();
        
        hh = 0;
        tt = -1;
        
        for (int i = 0;i < n;++i) {
            if (hh <= tt && q[hh] < i - k + 1) ++hh;
            while (hh <= tt && a[q[tt]] <= a[i]) --tt;
            q[++tt] = i;
            
            if (i >= k - 1) log.write(a[q[hh]] + " ");
        }
        
        log.flush();
        
        log.close();
        in.close();
    }
}
```
## KMP
### [kmp字符串](https://www.acwing.com/problem/content/833/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        char p[] = new char[100010];
        char s[] = new char[1000010];
        int ne[] = new int[100010];
        
        int n = Integer.valueOf(st.nextToken());
        st = new StringTokenizer(in.readLine());
        String s1 = st.nextToken();
        for (int i = 0;i < s1.length();++i) {
            p[i+1] = s1.charAt(i);
        }

        st = new StringTokenizer(in.readLine());    
        int m = Integer.valueOf(st.nextToken());
        
        st = new StringTokenizer(in.readLine());   
        String s2 = st.nextToken();
        for (int i = 0;i < s2.length();++i) {
            s[i+1] = s2.charAt(i);
        }
        
        
        for (int i = 2, j = 0;i <= n;++i) {
            while (j > 0 && p[i] != p[j+1]) j = ne[j];
            if (p[i] == p[j+1]) ++j;
            ne[i] = j;
        }
        
        int i = 1, j = 0;
        for (i = 1;i <= m;++i) {
            while (j > 0 && s[i] != p[j+1]) j = ne[j];
            if (s[i] == p[j+1]) ++j;
            if (j == n) {
                // 匹配成功
                log.write((i - n) + " ");
                j = ne[j];
            }
        }
        
        log.flush();
        log.close();
        in.close();
    }
}
```
## Tire字符串统计
### [Trie字符串统计](https://www.acwing.com/problem/content/837/)
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        Map<String, Integer> map = new HashMap<>();
        
        st = new StringTokenizer(in.readLine());   
        while (n-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());   
            }
            String op = st.nextToken();
            String value = st.nextToken();
            
            if ("I".equals(op)) {
                if (map.containsKey(value)) {
                    map.put(value, map.get(value) + 1);
                } else {
                    map.put(value, 1);
                }
            } else if ("Q".equals(op)) {
                if (map.containsKey(value)) {
                    out.write("" + map.get(value));
                    out.newLine();
                } else {
                    out.write("0");
                    out.newLine();
                }
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
}
```

```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static int N = 100010;
    private static int son[][] = new int[N][26];
    private static int cnt[] = new int[N * 26];
    private static int idx;
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        
        st = new StringTokenizer(in.readLine());   
        while (n-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());   
            }
            String op = st.nextToken();
            String value = st.nextToken();
            
            if ("I".equals(op)) {
                insert(value.toCharArray());
            } else {
                out.write("" + query(value.toCharArray()));
                out.newLine();
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
    
    private static void insert(char[] str) {
        int p = 0;
        for (int i = 0;i < str.length;++i) {
            int u = str[i] - 'a';
            if (son[p][u] == 0) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }
    
    private static int query(char[] str) {
        int p = 0;
        for (int i = 0;i < str.length;++i) {
            int u = str[i] - 'a';
            if (son[p][u] == 0) return 0;
            p = son[p][u];
        }
        
        return cnt[p];
    }
}
```
### [最大异或对](https://www.acwing.com/problem/content/145/)
```java
import java.util.*;

public class Main {
    
    private static int N = 100010; // 数字数量
    private static int M = 31 * N; // 行数
    private static int son[][] = new int[M][2]; // 每位0或1
    private static int idx;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int a[] = new int[n];
        
        for (int i = 0;i < n;++i) {
            a[i] = in.nextInt();
            insert(a[i]);
        }
        
        int res = 0;
        for (int i = 0;i < n;++i) {
            res = Math.max(res, query(a[i]));
        }
        
        System.out.println(res);
    }
    
    private static void insert(int x) {
        int p = 0;
        for (int i = 30;i >= 0;--i) {
            int s = x >> i & 1;
            if (son[p][s] == 0) son[p][s] = ++idx;
            p = son[p][s];
        }
    }
    
    private static int query(int x) {
        int p = 0;
        int res = 0;
        for (int i = 30;i >= 0;--i) {
            int s = (x >> i & 1) == 1 ? 0 : 1;
            if (son[p][s] != 0) {
                res += 1 << i;
                p = son[p][s];
            } else {
                s = s == 1 ? 0 : 1;
                p = son[p][s];
            }
        }
        
        return res;
    }
}
```
## 并查集
### [合并集合](https://www.acwing.com/problem/content/description/838/)
```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static int N = 100010;
    private static int p[] = new int[N];
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(in.readLine());
        
        int n = Integer.valueOf(st.nextToken());
        int m = Integer.valueOf(st.nextToken());
        
        for (int i = 0;i < n;++i) {
            p[i] = i;
        }
        
        st = new StringTokenizer(in.readLine());
        while (m-- != 0) {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(in.readLine());
            }
            String op = st.nextToken();
            int x = Integer.valueOf(st.nextToken());
            int y = Integer.valueOf(st.nextToken());
            
            if ("M".equals(op)) {
                p[find(x)] = find(y);
            } else {
                out.write(find(x) == find(y) ? "Yes" : "No");
                out.newLine();
            }
        }
        
        out.flush();
        out.close();
        in.close();
    }
    
    private static int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        
        return p[x];
    }
}
```

### [连通块中点的数量](https://www.acwing.com/problem/content/839/)
```java
import java.util.*;

public class Main {
    
    private static int N = 100010;
    private static int p[] = new int[N];
    private static int size[] = new int[N];
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int m = in.nextInt();
        
        for (int i = 0;i < n;++i) {
            p[i] = i;
            size[i] = 1;
        } 
        
        while (m-- != 0) {
            String op = in.next();
            
            if ("C".equals(op)) {
                int x = in.nextInt();
                int y = in.nextInt();
                if(find(x) == find(y)) continue;
                size[find(y)] = size[find(x)] + size[find(y)];
                p[find(x)] = find(y);
            } else if ("Q1".equals(op)) {
                int x = in.nextInt();
                int y = in.nextInt();
                System.out.println(find(x) == find(y) ? "Yes" : "No");
            } else {
                int x = in.nextInt();
                System.out.println(size[find(x)]);
            }
        }
    }
    
    private static int find(int x) {
        if (x != p[x]) {
            p[x] = find(p[x]);
        }
        
        return p[x];
    }
}
```

### [食物链](https://www.acwing.com/problem/content/242/)
```java
import java.util.*;

public class Main {
    
    private static int N = 50010;
    private static int p[] = new int[N];
    private static int d[] = new int[N];
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        int k = in.nextInt();
        
        for (int i = 1;i <= n;++i) p[i] = i;
        
        int res = 0;
        
        while (k-- != 0) {
            int t = in.nextInt();
            int x = in.nextInt();
            int y = in.nextInt();
            
            if (x > n || y > n) {
                res++;
            } else {
                int px = find(x);
                int py = find(y);
                
                if (t == 1) {
                    // 同类
                    if (px == py && (d[x] - d[y]) % 3 != 0) {
                        // 假的
                        res++;
                    } else if (px != py) {
                        // 真的
                        p[px] = py;
                        d[px] = d[y] - d[x];
                    }
                } else {
                    // X吃Y
                    if (px == py && (d[x] - d[y] - 1) % 3 != 0) {
                        res++;
                    } else if (px != py) {
                        p[px] = py;
                        d[px] = d[y] - d[x] + 1;
                    }
                }
            }
        }
        
        System.out.println(res);
    }

    /**
    * 压缩路径， 并查集可以多保存额外信息，此处保存了路径信息
    */
    private static int find(int x) {
        if (x != p[x]) {
            int t = find(p[x]);
            d[x] += d[p[x]];
            p[x] = t;
        }
        
        return p[x];
    }
}
```

## 堆
### [堆排序](https://www.acwing.com/problem/)
```java
import java.util.*;

public class Main {
    
    private static int n, m;
    private static int N = 100010;
    private static int h[] = new int[N];
    private static int size = 0;
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        n = in.nextInt();
        m = in.nextInt();
        
        for (int i = 1;i <= n;++i) h[i] = in.nextInt();
        size = n;
        
        // 调整树, 从最后的非叶子结点开始
        // 只要孩子节点小于该节点，就进行交换
        for (int i = n / 2;i != 0;--i) adjust(i);
        
        while (m-- != 0) {
            // 得到堆顶元素
            System.out.print(h[1] + " ");
            // 将堆顶元素和最后一个节点交互
            swap(1, size);
            // 逻辑删除
            size--;
            adjust(1);
        }
    }
    
    private static void adjust(int u) {
        int t = u;
        // 如果左子树存在，且孩子节点小于该节点
        if (u * 2 <= size && h[u * 2] < h[t]) {
            t = u * 2;
        }
        // 如果右子树存在，且孩子节点小于该节点
        if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) {
            t = u * 2 + 1;
        }
        if (u != t) {
            // 将本节点和孩子节点进行交换
            swap(u, t);
            // 递归判断子树
            adjust(t);
        }
    }

    private static void swap(int a, int b) {
        int temp = h[a];
        h[a] = h[b];
        h[b] = temp;
    }
}
```
