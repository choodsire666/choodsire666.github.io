**笔记来源：**[**黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案**](https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&vd_source=e8046ccbdc793e09a75eb61fe8e84a30)
## 1 基本原理和实现方式对比
**分布式锁**：满足分布式系统或集群模式下多进程可见并且互斥的锁。
分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路
![1653374296906.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034648450-2bd0d2d7-a054-42ba-a132-2911f70e0661.png#averageHue=%23f3f2f1&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u4ff5f11a&originHeight=808&originWidth=1616&originalType=binary&ratio=1&rotation=0&showTitle=false&size=336546&status=error&style=none&taskId=u728055f6-c814-418c-92c4-4cd794cb2ba&title=)

那么分布式锁他应该满足一些什么样的条件呢？
**可见性**：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思
**互斥**：互斥是分布式锁的最基本的条件，使得程序串行执行
**高可用**：程序不易崩溃，时时刻刻都保证较高的可用性
**高性能**：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能
**安全性**：安全也是程序中必不可少的一环
![1653381992018.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034686566-287e5742-a27c-4ac5-a0b6-2cc8abfc4fa1.png#averageHue=%23efe9e8&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u9ca9f33b&originHeight=569&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93865&status=error&style=none&taskId=u36065dc4-cfdc-4507-a235-fd664b8a4d8&title=)
常见的分布式锁有三种

- Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见
- Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁
- Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述

![1653382219377.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034722279-e1e5f6b5-be32-45d6-b4b8-bd50fa54fa8e.png#averageHue=%23d7c2c1&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u42fe56ff&originHeight=538&originWidth=1497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=163111&status=error&style=none&taskId=u7103227f-da70-4faa-b7a3-9cc067ccda1&title=)
## 2 Redis分布式锁的实现
实现分布式锁时需要实现的两个基本方法：

-  获取锁： 
   - 互斥：确保只能有一个线程获取锁
   - 非阻塞：尝试一次，成功返回true，失败返回false
-  释放锁： 
   - 手动释放
   - 超时释放：获取锁时添加一个超时时间

![1653382669900.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034762322-9103463c-5347-48fc-8a5f-c520a39ba980.png#averageHue=%23022130&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&height=54&id=uf35fa4e5&originHeight=72&originWidth=622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4497&status=error&style=none&taskId=uf2802254-32b3-467f-bc0f-d04edaf7967&title=&width=463)

**核心思路：**
我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可
![1653382830810.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034789975-7cdcd69a-4f54-4892-80e2-cbf8561853ce.png#averageHue=%23f8f8f8&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u359754b8&originHeight=664&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40253&status=error&style=none&taskId=ubd405279-3c1c-4d32-8787-760876d484c&title=)
## 3 实现分布式锁版本一
**加锁逻辑**
锁的基本接口
```java
public interface ILock {
    /**
     * 尝试获取锁
     *
     * @param timeoutSec 锁持有的超时时间，过期自动释放
     * @return true表示获取锁成功，false表示获取锁失败
     */
    boolean tryLock(long timeoutSec);

    /**
     * 释放锁
     */
    void unlock();
}
```

**SimpleRedisLock**
利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性
```java
private static final String KEY_PREFIX="lock:"
@Override
public boolean tryLock(long timeoutSec) {
    // 获取线程标示
    String threadId = Thread.currentThread().getId()
    // 获取锁
    Boolean success = stringRedisTemplate.opsForValue()
            .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS);
    return Boolean.TRUE.equals(success);
}
```
**释放锁逻辑**
SimpleRedisLock
释放锁，防止删除别人的锁
```java
public void unlock() {
    //通过del删除锁
    stringRedisTemplate.delete(KEY_PREFIX + name);
}
```

修改业务代码
```java
  @Override
    public Result seckillVoucher(Long voucherId) {
        // 1.查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        // 2.判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            // 尚未开始
            return Result.fail("秒杀尚未开始！");
        }
        // 3.判断秒杀是否已经结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            // 尚未开始
            return Result.fail("秒杀已经结束！");
        }
        // 4.判断库存是否充足
        if (voucher.getStock() < 1) {
            // 库存不足
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
        //创建锁对象(新增代码)
        SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);
        //获取锁对象
        boolean isLock = lock.tryLock(1200);
		//加锁失败
        if (!isLock) {
            return Result.fail("不允许重复下单");
        }
        try {
            //获取代理对象(事务)
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        } finally {
            //释放锁
            lock.unlock();
        }
    }
```
## 4 Redis分布式锁误删情况
**逻辑说明**：持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明
**解决方案**：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。
![1653385920025.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665034995154-07bdb459-62d4-4eac-999f-49a714553f26.png#averageHue=%23fafaf9&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u2fe784be&originHeight=642&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173010&status=error&style=none&taskId=uc0059af2-15c4-48b3-b050-1aea74ae3c8&title=)
## 5 解决Redis分布式锁误删问题
需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）
在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致

- 如果一致则释放锁
- 如果不一致则不释放锁

核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。

![1653387398820.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035114466-a8eb9be6-3881-4794-b4d6-a95cbf4854f4.png#averageHue=%23ebe4e3&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u86966b3e&originHeight=644&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147447&status=error&style=none&taskId=ub3ed2ff9-a970-4f01-ae08-cf004ec9f99&title=)
具体代码如下：加锁
```java
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
@Override
public boolean tryLock(long timeoutSec) {
   // 获取线程标示
   String threadId = ID_PREFIX + Thread.currentThread().getId();
   // 获取锁
   Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
   return Boolean.TRUE.equals(success);
}
```

释放锁
```java
public void unlock() {
    // 获取线程标示
    String threadId = ID_PREFIX + Thread.currentThread().getId();
    // 获取锁中的标示
    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
    // 判断标示是否一致
    if(threadId.equals(id)) {
        // 释放锁
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
```
**有关代码实操说明：**
在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。
## 6 分布式锁的原子性问题
**更为极端的误删逻辑说明**：线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，
![1653387764938.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035140166-5e026330-b68d-4e45-974f-89bb14e1c082.png#averageHue=%23f6f5f5&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u66e74f77&originHeight=697&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=275605&status=error&style=none&taskId=u9e82995e-5122-4f22-8c5d-93e33355508&title=)
## 7 Lua脚本解决多条命令原子性问题
Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：[https://www.runoob.com/lua/lua-tutorial.html](https://www.runoob.com/lua/lua-tutorial.html)，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。
这里重点介绍Redis提供的调用函数，语法如下：
```lua
redis.call('命令名称', 'key', '其它参数', ...)
```

例如，我们要执行set name jack，则脚本是这样：
```lua
-- 执行 set name jack
redis.call('set', 'name', 'jack')
```

例如，我们要先执行set name Rose，再执行get name，则脚本如下：
```lua
-- 先执行 set name jack
redis.call('set', 'name', 'Rose')
-- 再执行 get name
local name = redis.call('get', 'name')
-- 返回
return name
```

写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：
![1653392181413.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035237497-9951083d-fc0c-49fc-9d48-22711ac59b6a.png#averageHue=%23031f32&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u3776aaab&originHeight=163&originWidth=714&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17511&status=error&style=none&taskId=ud9c21109-27e2-45e4-ac83-5ec8098484b&title=)

例如，我们要执行`redis.call('set', 'name', 'jack')` 这个脚本，语法如下：
![1653392218531.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035249219-28911df3-7322-41e4-b704-fe158cdc1899.png#averageHue=%23022134&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u87629d70&originHeight=113&originWidth=668&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10316&status=error&style=none&taskId=u3be16857-4220-4ef3-a365-458b28d2902&title=)
如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：
![1653392438917.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035258342-b0015159-291e-46fd-bd03-d51afcc8f81f.png#averageHue=%23122c3f&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=u2455e6b0&originHeight=151&originWidth=1129&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91366&status=error&style=none&taskId=ufc44ff17-358f-4c46-bea4-4f4c39b2566&title=)
接下来我们来回一下我们释放锁的逻辑：

释放锁的业务流程是这样的

1. 获取锁中的线程标示
2. 判断是否与指定的标示（当前线程标示）一致
3. 如果一致则释放锁（删除）
4. 如果不一致则什么都不做

如果用Lua脚本来表示则是这样的：
最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样
```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```

## 8 利用Java代码调用Lua脚本改造分布式锁
lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。
我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股
![1653393304844.png](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665035339822-da96a45a-4919-44eb-8393-e596fd8fadf2.png#averageHue=%23eff3eb&clientId=u94722be3-b773-4&errorMessage=unknown%20error&from=drop&id=ub96f4a7a&originHeight=384&originWidth=822&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138307&status=error&style=none&taskId=u048ea5a7-41b3-434a-be0d-b193e5324e6&title=)

**Java代码**
```java
private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

public void unlock() {
    // 调用lua脚本
    stringRedisTemplate.execute(
            UNLOCK_SCRIPT,
            Collections.singletonList(KEY_PREFIX + name),
            ID_PREFIX + Thread.currentThread().getId());
}
//经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~
```
基于Redis的分布式锁实现思路：

- 利用`set nx ex`获取锁，并设置过期时间，保存线程标示
- 释放锁时先判断线程标示是否与自己一致，一致则删除锁 
   - 特性： 
      - 利用set nx满足互斥性
      - 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性
      - 利用Redis集群保证高可用和高并发特性

**总结**：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题
但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦
**测试逻辑：**
第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。
