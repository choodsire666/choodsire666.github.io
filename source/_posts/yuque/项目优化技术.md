## SpringCache
### 简介
Spring Cache是一个框架，实现了基于注解的缓冲功能，只需要简单的加一个注解，就能实现缓冲功能，大大简化我们业务中操作缓冲的代码。
spring cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过CacheManger接口统一不同的缓冲技术。CacheManager是Spring提供的各种缓冲技术抽象接口。
针对不同的缓存技术需要实现不同的CacheManager：

| **CacheManager** | **描述** |
| --- | --- |
| EhCacheCacheManager | 使用EhCache作为缓存技术 |
| GuavaCacheManager | 使用Google的GuavaCache作为缓存技术 |
| RedisCacheManager | 使用Redis作为缓存技术 |

### 注解
在SpringCache 中提供了很多缓冲操作的注解，常见以下几个：

| **注解** | **说明** |
| --- | --- |
| [@EnableCaching ](/EnableCaching ) | 开启缓存注解功能 |
| [@Cacheable ](/Cacheable ) | 在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 |
| [@CachePut ](/CachePut ) | 将方法的返回值放到缓存中 |
| [@CacheEvict ](/CacheEvict ) | 将一条或多条数据从缓存中删除 |

### CacheEvict注解
@CacheEvict 说明： 
	作用: 清理指定缓存
	value: 缓存的名称，每个缓存名称下面可以有多个key
	key: 缓存的key  ----------> 支持Spring的表达式语言SPEL语法
1.在 delete 方法上加注解@CacheEvict
当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用@CacheEvict注解, 具体的使用方式如下: 
```
/**
* CacheEvict：清理指定缓存
* value：缓存的名称，每个缓存名称下面可以有多个key
* key：缓存的key
*/
@CacheEvict(value = "userCache",key = "#p0")  //#p0 代表第一个参数
//@CacheEvict(value = "userCache",key = "#root.args[0]") //#root.args[0] 代表第一个参数
//@CacheEvict(value = "userCache",key = "#id") //#id 代表变量名为id的参数
@DeleteMapping("/{id}")
public void delete(@PathVariable Long id){
    userService.removeById(id);
}
```
### CachePut注解
@CachePut 说明： 
	作用: 将方法返回值，放入缓存
	value: 缓存的名称, 每个缓存名称下面可以有很多key
	key: 缓存的key  ----------> 支持Spring的表达式语言SPEL语法
1.save方法上加注解CachePut
当前UserController的save方法用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加注解CachePut,用法如下
```
/**
* CachePut：将方法返回值放入缓存
* value：缓存的名称，每个缓存名称下面可以有多个key
* key：缓存的key
*/
@CachePut(value = "userCache", key = "#user.id")
@PostMapping
public User save(User user){
    userService.save(user);
    return user;
}
```
### 在update方法上加注解@CacheEvict
在更新数据之后，数据库的数据已经发生了变更，我们需要将缓冲中对应的数据删除掉，避免出现数据库数据与缓冲数据不一致的情况
```
//@CacheEvict(value = "userCache",key = "#p0.id")   //第一个参数的id属性
//@CacheEvict(value = "userCache",key = "#user.id") //参数名为user参数的id属性
//@CacheEvict(value = "userCache",key = "#root.args[0].id") //第一个参数的id属性
@CacheEvict(value = "userCache",key = "#result.id")         //返回值的id属性
@PutMapping
public User update(User user){
    userService.updateById(user);
    return user;
}
```
### Cacheable注解
@Cacheable 说明:
	作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中
value: 缓存的名称，每个缓存名称下面可以有多个key
key: 缓存的key  ----------> 支持Spring的表达式语言SPEL语法
```
/**
* Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中
* value：缓存的名称，每个缓存名称下面可以有多个key
* key：缓存的key
*/
@Cacheable(value = "userCache",key = "#id")
@GetMapping("/{id}")
public User getById(@PathVariable Long id){
    User user = userService.getById(id);
    return user;
}
```

缓存非null值
在@Cacheable注解中，提供了两个属性分别为： condition， unless 。
condition : 表示满足什么条件, 再进行缓存 ;
unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ;
```
/**
 * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中
 * value：缓存的名称，每个缓存名称下面可以有多个key
 * key：缓存的key
 * condition：条件，满足条件时才缓存数据
 * unless：满足条件则不缓存
 */
@Cacheable(value = "userCache",key = "#id", unless = "#result == null")
@GetMapping("/{id}")
public User getById(@PathVariable Long id){
    User user = userService.getById(id);
    return user;
}
```
我们使用的时候只能够使用unless，因为在condition中，我们是无法获取到结果#result的 
###  ShardingJDBC介绍
#### 简介
Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。
使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。

Sharding-JDBC具有以下几个特点： 
1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。
3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。
# 前后端分离开发

1.开发人员同时负责前端和后端代码开发，分工不明确。
2.开发效率低
3.前后端代码混合在一个工程中，不便于管理
4.对开发人员要求高(即会前端，又会后端)，人员招聘困难
## 简介

前后端分离开发，就是在项目开发过程中，对于前端代码的开发又专门的前端开发人员负责，后端代码则由后端开发人员负责，前后端分离开发方式已经被越来越多的公司采用，成为当前项目开发的主流开发方式。
![image.png](https://raw.githubusercontent.com/choodsire666/blog-img/main/项目优化技术/fa2fdbcf1ffa5e7477f7ca77f6ea87a8.png)
前后端分离之后，不仅工程结构变化，后端项目上线部署时，与之前不同：
1). 之前: 前后端代码都混合在一起，我们只需要将前端和后端的代码统一打成jar包，直接运行就可以了。 
2). 现在: 拆分为前后端分离的项目后，最终部署时，后端工程会打成一个jar包，运行在Tomcat中(springboot内嵌的tomcat)。前端工程的静态资源，会直接部署在Nginx中进行访问。
## 开发路程
前后端分离开发后，面临一个问题，就是前端开发人员和后端开发人员如何配合来共同开发一个项目？
![image.png](https://raw.githubusercontent.com/choodsire666/blog-img/main/项目优化技术/4b82ab8f2835ac64dcd5bbbee793a585.png)
![image.png](https://raw.githubusercontent.com/choodsire666/blog-img/main/项目优化技术/918b017e7c81ce35dc64375b4b0db5ac.png)
1.定制接口：这里所说的接口不是我们之前在service,mapper层定义的interface;这里的接口（API)就是一个http的请求地址，主要就是去定义：请求路径，请求方式，请求参数，响应数据等内容。
2.前后端并行开发：依据定义好的接口信息，前端人员开发前端代码，服务端人员开发服务端的接口；开发中前后端都需要进行测试，后端需要通过对应的工具来进行接口的测试，前端需要根据接口定义的参数进行Mock数据模拟测试。
3.联调：当前后端都开发完毕并且自测通过之后，就可以进行前后端的联调测试了，这一阶段主要就是 校验接口的参数格式。
4.提测：前后端联调测试通过之后，就可以将项目部署到测试服务器，进行自动化测试了
## 前端技术栈
### 开发工具
Visual Studio Code (简称VsCode)

Hbuilder
### 技术框架
A. Node.js:  Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。(类似于java语言中的JDK)。
B. Vue : 目前最火的的一个前端javaScript框架。
C. ElementUI: 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库，通过ElementUI组件可以快速构建项目页面。
D. Mock: 生成随机数据，拦截 Ajax 请求，前端可以借助于Mock生成测试数据进行功能测试。
E. Webpack: webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。
