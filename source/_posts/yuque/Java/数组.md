---

## 本章专题与脉络
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928810.png#clientId=uce38430e-633c-4&from=url&id=VLUzP&originHeight=2305&originWidth=1607&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u360a1f43-aea8-44e0-989f-2c5fd3ecd95&title=)
## 1. 数组的概述
### 1.1 为什么需要数组
**需求分析1：**
需要统计某公司50个员工的工资情况，例如计算平均工资、找到最高工资等。用之前知识，首先需要声明50个变量来分别记录每位员工的工资，这样会很麻烦。因此我们可以将所有的数据全部存储到一个容器中统一管理，并使用容器进行计算。
**需求分析2：**
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928811.jpg#clientId=uce38430e-633c-4&from=url&id=vmUR6&originHeight=1080&originWidth=1165&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf779dde2-a767-4fba-9e15-98bb1818535&title=)
容器的概念：

- **生活中的容器：**水杯（装水等液体），衣柜（装衣服等物品），集装箱（装货物等）。
- **程序中的容器：**将多个数据存储到一起，每个数据称为该容器的元素。
### 1.2 数组的概念

- 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。
- 数组中的概念
   - 数组名
   - 下标（或索引）
   - 元素
   - 数组的长度

![](https://gitee.com/lvweixing/pictures/raw/master/202304241928812.png#clientId=uce38430e-633c-4&from=url&id=Vr4ar&originHeight=635&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u00927e9b-ee7b-4845-94b9-d70699c3e7b&title=)
**数组的特点：**

- 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。
- 创建数组对象会在内存中开辟一整块连续的空间。占据的空间的大小，取决于数组的长度和数组中元素的类型。
- 数组中的元素在内存中是依次紧密排列的，有序的。
- 数组，一旦初始化完成，其长度就是确定的。数组的长度一旦确定，就不能修改。
- 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。
- 数组名中引用的是这块连续空间的首地址。
### 1.3 数组的分类
**1、按照元素类型分：**

- 基本数据类型元素的数组：每个元素位置存储基本数据类型的值
- 引用数据类型元素的数组：每个元素位置存储对象（本质是存储对象的首地址）（在面向对象部分讲解）

**2、按照维度分：**

- 一维数组：存储一组数据
- 二维数组：存储多组数据，相当于二维表，一行代表一组数据，只是这里的二维表每一行长度不要求一样。

![](https://gitee.com/lvweixing/pictures/raw/master/202304241928813.png#clientId=uce38430e-633c-4&from=url&id=wxty5&originHeight=312&originWidth=475&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0a320f68-d32d-43b0-ae3a-7b77cc683fa&title=)

## 2. 一维数组的使用
### 2.1 一维数组的声明
**格式：**
```
x


//推荐
元素的数据类型[] 一维数组的名称;
 
//不推荐
元素的数据类型  一维数组名[];
```
**举例：**
**数组的声明，需要明确：**
（1）数组的维度：在Java中数组的符号是[]，[]表示一维，[][]表示二维。
（2）数组的元素类型：即创建的数组容器可以存储什么数据类型的数据。元素的类型可以是任意的Java的数据类型。例如：int、String、Student等。
（3）数组名：就是代表某个数组的标识符，数组名其实也是变量名，按照变量的命名规范来命名。数组名是个引用数据类型的变量，因为它代表一组数据。
**举例：**
注意：Java语言中声明数组时不能指定其长度(数组中元素的个数)。 例如： int a[5]; //非法
### 2.2 一维数组的初始化
#### 2.2.1 静态初始化

- 如果数组变量的初始化和数组元素的赋值操作同时进行，那就称为静态初始化。
- 静态初始化，本质是用静态数据（编译时已知）为数组初始化。此时数组的长度由静态数据的个数决定。
- **一维数组声明和静态初始化格式1：**

例如，定义存储1，2，3，4，5整数的数组容器。

- **一维数组声明和静态初始化格式2：**

例如，定义存储1，2，3，4，5整数的数组容器
**举例：**
#### 2.2.2 动态初始化
数组变量的初始化和数组元素的赋值操作分开进行，即为动态初始化。
动态初始化中，只确定了元素的个数（即数组的长度），而元素值此时只是默认值，还并未真正赋自己期望的值。真正期望的数据需要后续单独一个一个赋值。
**格式：**

- [长度]：数组的长度，表示数组容器中可以最多存储多少个元素。
- **注意：数组有定长特性，长度一旦指定，不可更改。**和水杯道理相同，买了一个2升的水杯，总容量就是2升是固定的。

**举例1：正确写法**
**举例2：错误写法**
### 2.3 一维数组的使用
#### 2.3.1 数组的长度

- 数组的元素总个数，即数组的长度
- 每个数组都有一个属性length指明它的长度，例如：arr.length 指明数组arr的长度(即元素个数)
- 每个数组都具有长度，而且一旦初始化，其长度就是确定，且是不可变的。
#### 2.3.2 数组元素的引用
**如何表示数组中的一个元素？**
每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)或下标，可以通过数组的索引/下标访问到数组中的元素。
**数组的下标范围？**
Java中数组的下标从[0]开始，下标范围是[0, 数组的长度-1]，即[0, 数组名.length-1]
数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];
**举例**
### 2.4 一维数组的遍历
将数组中的每个元素分别获取出来，就是遍历。for循环与数组的遍历是绝配。
**举例1**
**举例2**
### 2.5 数组元素的默认值
数组是引用类型，当我们使用动态初始化方式创建数组时，元素值只是默认值。例如：
对于基本数据类型而言，默认初始化值各有不同。
对于引用数据类型而言，默认初始化值为null（注意与0不同！)
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928814.png#clientId=uce38430e-633c-4&from=url&id=uiDs4&originHeight=410&originWidth=767&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u662335ac-1046-4767-93f4-3d339e819ef&title=)
## 3. 一维数组内存分析
### 3.1 Java虚拟机的内存划分
为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928815.png#clientId=uce38430e-633c-4&from=url&id=FaeAF&originHeight=573&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u615d924d-a08f-4b7c-a950-2d410fa345e&title=)

| 区域名称 | 作用 |
| --- | --- |
| 虚拟机栈 | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度
的各种基本数据类型、对象引用，方法执行完，自动释放。 |
| 堆内存 | 存储对象（包括数组对象），new来创建的，都存储在堆内存。 |
| 方法区 | 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。 |
| 本地方法栈 | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
| 程序计数器 | 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 |

### 3.2 一维数组在内存中的存储
#### 1、一个一维数组内存图
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928816.jpg#clientId=uce38430e-633c-4&from=url&id=vnIDY&originHeight=410&originWidth=1125&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6678b737-3794-489f-8cc2-b5b72279ef5&title=)
#### 2、数组下标为什么是0开始
因为第一个元素距离数组首地址间隔0个单元格。
#### 3、两个一维数组内存图
两个数组独立
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928817.jpg#clientId=uce38430e-633c-4&from=url&id=zcQW3&originHeight=629&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub4ff894b-e1fb-4ee7-8dea-7c2ff49f386&title=)
#### 4、两个变量指向一个一维数组
两个数组变量本质上代表同一个数组。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928818.jpg#clientId=uce38430e-633c-4&from=url&id=haLWn&originHeight=752&originWidth=1128&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uce46e8f0-5a3b-41c9-bcb4-b5561f756b4&title=)
## 4. 一维数组的应用
**案例1：**升景坊单间短期出租4个月，550元/月（水电煤公摊，网费35元/月），空调、卫生间、厨房齐全。屋内均是IT行业人士，喜欢安静。所以要求来租者最好是同行或者刚毕业的年轻人，爱干净、安静。
案例2：输出英文星期几
用一个数组，保存星期一到星期天的7个英语单词，从键盘输入1-7，显示对应的单词{"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"}
**案例3：**从键盘读入学生成绩，找出最高分，并输出学生成绩等级。

- 成绩>=最高分-10 等级为’A’ 
- 成绩>=最高分-20 等级为’B’
- 成绩>=最高分-30 等级为’C’ 
- 其余 等级为’D’

提示：先读入学生人数，根据人数创建int数组，存放学生成绩。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928819.png#clientId=uce38430e-633c-4&from=url&id=Laay9&originHeight=469&originWidth=332&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub0658c60-6274-406d-a3a0-dd9d7c6ea7a&title=)
## 5. 多维数组的使用
### 5.1 概述

- Java 语言里提供了支持多维数组的语法。
- 如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格，像Excel中的表格、围棋棋盘一样。![](https://gitee.com/lvweixing/pictures/raw/master/202304241928820.png#clientId=uce38430e-633c-4&from=url&id=II5hw&originHeight=496&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3f4b93b0-8c51-4fd3-8788-1b688219b22&title=)
- **应用举例1：**某公司2022年全年各个月份的销售额进行登记。按月份存储，可以使用一维数组。如下：
- **应用举例2：**

高一年级三个班级均由多个学生姓名构成一个个数组。如下：
那从整个年级看，我们可以声明一个二维数组。如下：

- **应用举例3：**

![](https://gitee.com/lvweixing/pictures/raw/master/202304241928821.png#clientId=uce38430e-633c-4&from=url&id=p4wmB&originHeight=124&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u877ed0c0-228b-4f54-91d2-25128493fd7&title=)
蓝框的几个元素，可以使用一维数组来存储。但现在发现每个元素下还有下拉框，其内部还有元素，那就需要使用二维数组来存储：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928822.png#clientId=uce38430e-633c-4&from=url&id=aDatH&originHeight=239&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u88fc9a5a-76bc-4cfa-aafd-6753211c965&title=)

- 使用说明![](https://gitee.com/lvweixing/pictures/raw/master/202304241928823.png#clientId=uce38430e-633c-4&from=url&id=miy5S&originHeight=196&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8c7e93ab-ff93-4526-a862-670d517c5dc&title=)
- 对于二维数组的理解，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。
- 其实，从数组底层的运行机制来看，其实没有多维数组。
### 5.2 声明与初始化
#### 5.2.1 声明
二维数组声明的语法格式：
例如：
面试：
#### 5.2.2 静态初始化
**格式：**
定义一个名称为arr的二维数组，二维数组中有三个一维数组

- 每一个一维数组中具体元素也都已初始化
   - 第一个一维数组 arr[0] = {3,8,2};
   - 第二个一维数组 arr[1] = {2,7};
   - 第三个一维数组 arr[2] = {9,0,1,6};
- 第三个一维数组的长度表示方式：arr[2].length;
- 注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组。
- 举例1：
- 举例2：
#### 5.2.3 动态初始化
如果二维数组的每一个数据，甚至是每一行的列数，需要后期单独确定，那么就只能使用动态初始化方式了。动态初始化方式分为两种格式：
**格式1：规则二维表：每一行的列数是相同的**
举例：

- 定义了名称为arr的二维数组
- 二维数组中有3个一维数组
- 每一个一维数组中有2个元素
- 一维数组的名称分别为arr[0], arr[1], arr[2]
- 给第一个一维数组1脚标位赋值为78写法是：arr[0][1] = 78;

**格式2：不规则：每一行的列数不一样**
举例：

- 二维数组中有3个一维数组。
- 每个一维数组都是默认初始化值null (注意：区别于格式1）
- 可以对这个三个一维数组分别进行初始化：arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2];
- 注：int[][]arr = new int[][3]; //非法

练习：
### 5.3 数组的长度和角标

- 二维数组的长度/行数：二维数组名.length
- 二维数组的某一行：二维数组名[行下标]，此时相当于获取其中一组数据。它本质上是一个一维数组。行下标的范围：[0, 二维数组名.length-1]。此时把二维数组看成一维数组的话，元素是行对象。
- 某一行的列数：二维数组名[行下标].length，因为二维数组的每一行是一个一维数组。
- 某一个元素：二维数组名[行下标][列下标]，即先确定行/组，再确定列。
### 5.4 二维数组的遍历

- 格式：
- 举例：
### 5.5 内存解析
二维数组本质上是元素类型是一维数组的一维数组。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928824.png#clientId=uce38430e-633c-4&from=url&id=hyBRr&originHeight=278&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua9dcc476-51eb-42f2-a66a-b5e4cf3658a&title=)
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928825.png#clientId=uce38430e-633c-4&from=url&id=hfXFn&originHeight=244&originWidth=964&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5288a5e6-fe98-4b0c-be67-dff25f4cd85&title=)
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928826.png#clientId=uce38430e-633c-4&from=url&id=hwiCd&originHeight=376&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u844e09ee-6a51-4627-b074-c133c716004&title=)
### 5.6 应用举例
**案例1：**获取arr数组中所有元素的和。
提示：使用for的嵌套循环即可。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928827.png#clientId=uce38430e-633c-4&from=url&id=LbWC0&originHeight=233&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc455f08d-5ce2-482d-bd14-3fc49a9413f&title=)
**案例2：**声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是： 
**案例3：**使用二维数组打印一个 10 行杨辉三角。
提示：

1. 第一行有 1 个元素, 第 n 行有 n 个元素
2. 每一行的第一个元素和最后一个元素都是 1
3. 从第三行开始, 对于非第一个元素和最后一个元素的元素。即：

![](https://gitee.com/lvweixing/pictures/raw/master/202304241928828.png#clientId=uce38430e-633c-4&from=url&id=u5MKV&originHeight=280&originWidth=431&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue252a6c6-3e94-4c74-b656-8890ca7240b&title=)
## 6. 数组的常见算法
### 6.1 数值型数组特征值统计

- 这里的特征值涉及到：平均值、最大值、最小值、总和等

**举例1：**数组统计：求总和、均值
**举例2：**求数组元素的总乘积
**举例3：**求数组元素中偶数的个数
**举例4：**求数组元素的最大值
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928829.png#clientId=uce38430e-633c-4&from=url&id=NDTih&originHeight=122&originWidth=757&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ba5dbe5-4990-4b7b-bcae-b87dc5b4830&title=)
**举例5：**找最值及其第一次出现的下标
**举例6：**找最值及其所有最值的下标
优化
**举例7(难)：**输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。求所有子数组的和的最大值。要求时间复杂度为O(n)。例如：输入的数组为1, -2, 3, -10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，因此输出为该子数组的和18。
**举例8：评委打分**
分析以下需求，并用代码实现：
（1）在编程竞赛中，有10位评委为参赛的选手打分，分数分别为：5，4，6，8，9，0，1，2，7，3
（2）求选手的最后得分（去掉一个最高分和一个最低分后其余8位评委打分的平均值）
### 6.2 数组元素的赋值与数组复制
**举例1：**杨辉三角（见二维数组课后案例）
**举例2：**使用简单数组
(1)创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。
(2)使用大括号{}，把array1初始化为8个素数：2,3,5,7,11,13,17,19。
(3)显示array1的内容。
(4)赋值array2变量等于array1，修改array2中的偶索引元素，使其等于索引值(如array[0]=0,array[2]=2)。打印出array1。 array2 = array1;
**思考：**array1和array2是什么关系？
**拓展：**修改题目，实现array2对array1数组的复制
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928830.jpg#clientId=uce38430e-633c-4&from=url&id=QcYRO&originHeight=681&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c244b39-fd08-4803-952a-76681a87416&title=)![](https://gitee.com/lvweixing/pictures/raw/master/202304241928831.jpg#clientId=uce38430e-633c-4&from=url&id=lqWkf&originHeight=674&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufebff109-670a-4776-a3ec-1eaeae17156&title=)
**举例3：**一个数组，让数组的每个元素去除第一个元素，得到的商作为被除数所在位置的新值。
**举例4：**创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同。 
**举例5：**扑克牌
案例：遍历扑克牌
遍历扑克牌，效果如图所示：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928832.png#clientId=uce38430e-633c-4&from=url&id=e0eWk&originHeight=97&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8cb81feb-d907-4762-bcd8-a1190a8b044&title=)
提示：使用两个字符串数组，分别保存花色和点数，再用一个字符串数组保存最后的扑克牌。String[] hua = {"黑桃","红桃","梅花","方片"};String[] dian = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"};
拓展：在上述基础上，增加大王、小王。
**举例6：**回形数
从键盘输入一个整数（1~20） ，则以该数字为矩阵的大小，把1,2,3…n*n 的数字按照顺时针螺旋的形式填入其中。
例如： 输入数字2，则程序输出： 1 2 4 3 
输入数字3，则程序输出： 1 2 3 8 9 4 7 6 5 输入数字4， 则程序输出： 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7
### 6.3 数组元素的反转
**实现思想：**数组对称位置的元素互换。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928833.png#clientId=uce38430e-633c-4&from=url&id=cJBwZ&originHeight=422&originWidth=973&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u89f395b7-d1ff-4e2b-8604-bfbf01faf9d&title=)
或
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928834.png#clientId=uce38430e-633c-4&from=url&id=D4M2q&originHeight=261&originWidth=729&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub639a3ce-a3b8-4316-aff4-c92756fbf53&title=)
### 6.4 数组的扩容与缩容
**数组的扩容**
题目：现有数组 int[] arr = new int[]{1,2,3,4,5}; ，现将数组长度扩容1倍，并将10,20,30三个数据添加到arr数组中，如何操作？
**数组的缩容**
题目：现有数组 int[] arr={1,2,3,4,5,6,7}。现需删除数组中索引为4的元素。
### 6.5 数组的元素查找
**1、顺序查找**
顺序查找：挨个查看
要求：对数组元素的顺序没要求
**2、二分查找**
举例：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928835.png#clientId=uce38430e-633c-4&from=url&id=MwlMX&originHeight=458&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08134302-9b1d-4855-9449-75e077078aa&title=)
实现步骤：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928836.png#clientId=uce38430e-633c-4&from=url&id=T1EIv&originHeight=780&originWidth=899&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u064e18b2-c3bf-42e1-be29-10afa165b32&title=)
### 6.6 数组元素排序
#### 6.6.1 算法概述

- **定义**
   - 排序：假设含有n个记录的序列为{R1，R2，...,Rn},其相应的关键字序列为{K1，K2，...,Kn}。将这些记录重新排序为{Ri1,Ri2,...,Rin},使得相应的关键字值满足条Ki1<=Ki2<=...<=Kin,这样的一种操作称为排序。
   - 通常来说，排序的目的是快速查找。
- **衡量排序算法的优劣：**
   - 时间复杂度：分析关键字的比较次数和记录的移动次数
   - 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)<O(nn)
   - 空间复杂度：分析排序算法中需要多少辅助内存
   - 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。![](https://gitee.com/lvweixing/pictures/raw/master/202304241928837.png#clientId=uce38430e-633c-4&from=url&id=erXVf&originHeight=259&originWidth=426&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uff82a9b2-6f02-44b0-8315-1e22b5b050f&title=)
#### 6.6.2 排序算法概述

- **排序算法分类：内部排序和外部排序**
   - 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
   - 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。
- **十大内部排序算法**

数组的排序算法很多，实现方式各不相同，时间复杂度、空间复杂度、稳定性也各不相同：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928838.png#clientId=uce38430e-633c-4&from=url&id=CFVe9&originHeight=1272&originWidth=1882&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1d418b5a-f348-4625-b93d-b2f213830c2&title=)
常见时间复杂度所消耗的时间从小到大排序：
**O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)**
注意，经常将以2为底n的对数简写成logn。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928839.png#clientId=uce38430e-633c-4&from=url&id=lLe4A&originHeight=454&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue8aa673c-8300-4ea1-af94-64cc6904a93&title=)
#### 6.6.3 冒泡排序（Bubble Sort）
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928840.png#clientId=uce38430e-633c-4&from=url&id=hSOBe&originHeight=515&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5f4b7586-1db1-43eb-8f37-38c143448eb&title=)
**排序思想：**

1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。

![](https://gitee.com/lvweixing/pictures/raw/master/202304241928841.png#clientId=uce38430e-633c-4&from=url&id=sbkur&originHeight=473&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u343ffcfb-08d1-4510-aca6-aae9cb25813&title=)
**动态演示：**[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)
**冒泡排序优化（选讲）**
#### 6.6.4 快速排序
快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种，快速排序的时间复杂度为O(nlog(n))。
快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。
排序思想：

1. 从数列中挑出一个元素，称为"基准"（pivot），
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

**动态演示：**[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)
图示1：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928842.png#clientId=uce38430e-633c-4&from=url&id=jSpE9&originHeight=369&originWidth=846&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ec262e0-828b-407c-9be7-89b952cbcec&title=)
图示2：
第一轮操作：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928843.png#clientId=uce38430e-633c-4&from=url&id=Zuz7s&originHeight=736&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub6ed20f0-72f8-49f5-956d-d73dec46df5&title=)
第二轮操作：
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928844.png#clientId=uce38430e-633c-4&from=url&id=KUDDQ&originHeight=659&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc7b2a810-e22d-4afe-931f-30539106b67&title=)

#### 6.6.5 内部排序性能比较与选择

- 性能比较
   - **从平均时间而言**：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。
   - **从算法简单性看**：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。
   - **从稳定性看**：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序
   - **从待排序的记录数n的大小看**，n较小时，宜采用简单排序；而n较大时宜采用改进排序。
- 选择
   - 若n较小(如n≤50)，可采用直接插入或直接选择排序。当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。
   - 若文件初始状态基本有序(指正序)，则应选用直接插入、冒泡或随机的快速排序为宜；
   - 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。
## 7. Arrays工具类的使用
java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。 比如：

- 数组元素拼接
   - static String toString(int[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（"[]"）中。相邻元素用字符 ", "（逗号加空格）分隔。形式为：[元素1，元素2，元素3。。。]
   - static String toString(Object[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（"[]"）中。相邻元素用字符 ", "（逗号加空格）分隔。元素将自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回类型@hash值，如果重写则按重写返回的字符串进行拼接。
- 数组排序
   - static void sort(int[] a) ：将a数组按照从小到大进行排序
   - static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列
   - static void sort(Object[] a) ：根据元素的自然顺序对指定对象数组按升序进行排序。
   - static  void sort(T[] a, Comparator<? super T> c) ：根据指定比较器产生的顺序对指定对象数组进行排序。
- 数组元素的二分查找
   - static int binarySearch(int[] a, int key) 、static int binarySearch(Object[] a, Object key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数。
- 数组的复制
   - static int[] copyOf(int[] original, int newLength) ：根据original原数组复制一个长度为newLength的新数组，并返回新数组
   - static  T[] copyOf(T[] original,int newLength)：根据original原数组复制一个长度为newLength的新数组，并返回新数组
   - static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组
   - static  T[] copyOfRange(T[] original,int from,int to)：复制original原数组的[from,to)构成新数组，并返回新数组
- 比较两个数组是否相等
   - static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同
   - static boolean equals(Object[] a,Object[] a2)：比较两个数组的长度、元素是否完全相同
- 填充数组
   - static void fill(int[] a, int val) ：用val值填充整个a数组
   - static void fill(Object[] a,Object val)：用val对象填充整个a数组
   - static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val值
   - static void fill(Object[] a, int fromIndex, int toIndex, Object val) ：将a数组[fromIndex,toIndex)部分填充为val对象

举例：java.util.Arrays类的sort()方法提供了数组元素排序功能：
## 8. 数组中的常见异常
### 8.1 数组角标越界异常
当访问数组元素时，下标指定超出[0, 数组名.length-1]的范围时，就会报数组下标越界异常：ArrayIndexOutOfBoundsException。
创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是**不能出现**的，一旦出现了，就必须要修改我们编写的代码。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928845.jpg#clientId=uce38430e-633c-4&from=url&id=nlRW7&originHeight=186&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5472f75-59e2-4891-8252-2c888b9ec10&title=)
### 8.2 空指针异常
观察一下代码，运行后会出现什么结果。
因为此时数组的每一行还未分配具体存储元素的空间，此时arr[0]是null，此时访问arr[0][0]会抛出NullPointerException 空指针异常。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928846.jpg#clientId=uce38430e-633c-4&from=url&id=mNv1Q&originHeight=205&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u98dce54d-78f8-4a7a-bc12-485b2ae7466&title=)
**空指针异常在内存图中的表现**
![](https://gitee.com/lvweixing/pictures/raw/master/202304241928847.png#clientId=uce38430e-633c-4&from=url&id=RqjuP&originHeight=212&originWidth=979&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u79e7e138-7bfc-4caf-ab35-ee74f1b2922&title=)
**小结：空指针异常情况**

```
xxxxxxxxxx


数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3,...};
 
或
    
数据类型[] 数组名;
数组名 = new 数据类型[]{元素1,元素2,元素3,...};
```

   - new：关键字，创建数组使用的关键字。因为数组本身是引用数据类型，所以要用new创建数组实体。
```
xxxxxxxxxx


int[] monthData = new int[]{23,43,22,34,55,65,44,67,45,78,67,66};
```
如果改写为按季度为单位存储怎么办呢？
```
xxxxxxxxxx


yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];
```

```
xxxxxxxxxx


一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
```

